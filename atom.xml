<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>皮之鲲</title>
  
  <subtitle>总不能还没努力就向生活妥协</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-21T03:00:03.848Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>皮皮鲲</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>软件测试执行阶段</title>
    <link href="http://yoursite.com/2020/06/20/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5/"/>
    <id>http://yoursite.com/2020/06/20/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5/</id>
    <published>2020-06-20T00:33:56.000Z</published>
    <updated>2020-06-21T03:00:03.848Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="软件测试执行阶段"><a href="#软件测试执行阶段" class="headerlink" title="软件测试执行阶段"></a>软件测试执行阶段</h1><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>定义：单元测试是指对软件中的<strong>最小</strong>可测试单元或基本组成单元进行检查和验证。</p><p>单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。</p><p>一般是由程序员来负责</p><p>经常与单元测试联系起来的另外- 些开发活动包括<strong>代码走读，静态分析和动态分析</strong>。</p><p><strong>代码走读</strong>就是开发人员之间随机的互相阅读代码，检查其编写正确.与否的代码检查方式。形式上可以遵从同行评审的结构化的正规检视、走查、单人复审等;人工走读时，检查单可以按照头脑风暴、亲和图、鱼骨图方法形成系统化的检查树和处理机制;工具走读可以借助-些商用的测试工具和自己开发的辅助工具进行走读。</p><p><strong>静态分析</strong>就是对软件的源代码进行研读，查找错误或收集一些度量数据，并不需要对代码进行编译和执行。</p><p><strong>动态分析</strong>就是通过观察软件运行时的动作，来提供执行跟踪，时间分析，以及测试覆盖度方面的信息。</p><p>单元的选取原则：</p><p>因此，单元测试中选取的单元应具有明确的功能定义、性能定义以及连接其他部分的接口定义等，且应可以清晰地与其他单元区分开来。从某种意义上而言，单元的概念已经护展为组件。</p><p>案例：</p><p>单元可以认为是人为规定的最小的被测功能模块。<br>1.对于C语言这类面向过程的开发语言，单元可以是.一个函数或子过程。在特殊情况下，若存在几个函数之间具有强耦合性，导致函数关系非常密切，则应将这几个函数共同作为一个单元来测试。</p><p>2.对于C++、C#或Java语 言等面向对象的开发语言，单元一-般指一个类。然而，某些基础类可能非常庞大，涉及大量属性和方法，甚至需要几个开发人员来编码完成，则若将该类作为一个单元来测试并不合适，此时的测试将上升到集成测试的层面。</p><p>3.在图形化软件中，单元可以是一个窗口或一一个菜单。</p><p><strong>单元测试的重要性</strong></p><p>1、时间方面<br>如果做好了单元测试，在系统集成联调时会非常顺利，也因此会节约很多时间，反之那些由于因为时间原因不做单元测试的则在集成时总会遇到那些本应该在单元测试就能发现的问题，而这种问题往往很难让开发人员预料到。</p><p>2、测试效果</p><p>根据测试经验，单元测试的效果是非常明显的。</p><p>首先，它是测试阶段的基础，做好了单元测试，在做后期的集成测试和系统测试时就很顺利。<br>其次，在单元测试过程中能发现- - 些很深层次的问题，同时还会发现一- 些很容易发现但在集成测试和系统测试很难发现的问题。</p><p>最后，单元测试关注的范围也特殊，它不仅仅是证明这些代码做了什么，最重要的是代码是如何做的,是否做了它该做的事情而没有做不该做的事情。</p><p>3、测试成本.<br>在单元测试时某些问题就很容易发现。如果在后期的测试中发现问题所花的成本将成指数上升，同理还有定位问题和解决问题的费用也是成指数上升的，这就是要尽可能早地排除尽可能多的缺陷来减少后期成本的因素之一。</p><p>4、产品质量<br>单元测试的好与坏直接影响到产品的质量，可能就是由于代码中的某-一个小错误就导致了整个产品的质量降低个指标，或者导致更严重的后果，如果做好了单元测试这种情况是可以完全避免的。</p><p><strong>单元测试的内容</strong></p><p>1、单元功能测试</p><p>➢单元设计的功能点是否全部实现。</p><p>➢运算的优先级和先后执行顺序是否正确。</p><p>➢计算中精度的处理是否正确。</p><p>➢计算中的误差是否会无限放大。</p><p>2、模块接口测试</p><p>在单元测试的开始，应对所测模块的数据流进行测试。如果数据不能正确地输入和输出，就不能进行其他测试。对模块接口可能需要进行下面的测试项目:</p><p>➢调用所测模块时的输入参数与模块的形式参数在个数、属性、顺序上是否匹配。</p><p>➢所测模块调用子模块时，它输入给子模块的参数与子模块的形式参数在个数、属性、顺序上是否匹配。</p><p>➢是否修改了只作输入用的形式参数。</p><p>➢输出给标准函数的参数在个数、属性、顺序上是否正确。</p><p>➢全局变量的定义在各模块中是否致。</p><p>➢限制是否通过形式参数来传送。</p><p>➢模块对外部文件、数据库进行输入输出时，必须对文件操作进行测试。例如，缓冲区的大小、是否在读写文件前打开文件，在结束前关闭文件等。</p><p>3、内部数据流测试</p><p>内部数据流测试包括以下几点:</p><p>➢不正确或不一致的数据类型说明。</p><p>➢使用尚未赋值或尚未初始化的变量。</p><p>➢错误的初始值或错误的默认值。</p><p>➢变量名拼写错误或书写错误。</p><p>➢不一致的数据类型。</p><p>➢全局变量对模块是否产生影响。</p><p>4、逻辑路径测试</p><p>逻辑路径测试包括以下几点:</p><p>➢是否到达重要的功能点路径。</p><p>➢逻辑判断的边界点是否正确。</p><p>➢异常/错误处理。</p><p><strong>驱动模块和桩模块</strong></p><p>单元测试一般不考虑每个模块与其他模块之间的关系，但单元本身并不是一个独立的程序，往往需要基于被测单元的接口开发相应的驱动模块和桩模块通过驱动模块和桩模块搭建单元测试环境。</p><p><strong>驱动模块</strong>是模拟被测单元的上级模块，用于接受测试数据,启动被测模块和输出结果。</p><p><strong>桩模块</strong>是模拟被测单元所调用的模块。有时,需要使用子模块的接口,才能做少量数据操作,并验证和打印入口处的信息,然后返回,桩模块不包含原模块的所有细节。</p><p>案例：</p><p><img src="/2020/06/20/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5/1592703146365.png" alt="驱动模块和桩模块"></p><p>1、写两个模块Sd和Se分别代替D模块和E模块(函数名、返回值、传递的参数相同) ,这样B模块就可以通过编译了。Sd模块和Se模块就是桩模块。</p><p>2、写一个模块Da用来代替A模块，里面包含main函数，可以在main函数中调用B模块,让B模块运行起来。Da模块就是驱动模块。</p><p>使用条件：</p><p>当需要模拟的单元比较简单时，无需专门设计驱动模块或桩模块。</p><p>例如:</p><ul><li><p>代码段很短</p></li><li><p>代码结构简单</p></li><li><p>不含有复杂的循环和逻辑判断</p></li><li><p>不涉及复杂的动态内存分配和释放</p></li></ul><h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><p><strong>集成测试</strong>(也叫组装测试、联合测试)是在单元测试的基础上，将所有已通过单元测试的模块按照概要设计的要求组装为子系统或系统，进行集成测试。</p><p>实践表明，一些模块虽然能够单独地工作，但并不能保证连接起来也能正常的工作。一些局部反映不出来的问题，在全局上很可能暴露出来。进行集成测试，<strong>目的</strong>是确保各单元模块组合在一起后能够按既定意图协作运行，并确保增量的行为正确。</p><p>集成测试的内容包括模块之间的接口以及集成后的功能。它使用黑盒测试方法测试集成的功能，并对以前的集成进行回归测试。</p><ul><li><p>将各模块连接起来时，穿越模块接口的数据是否会丢失。</p></li><li><p>各子功能组合起来能否达到预期要求的父功能。</p></li><li><p>一个模块的功能是否会对其他模块的功能产生不利影响。</p></li><li><p>全局数据结构是否有问题，是否会被异常修改。</p></li><li><p>集成后，单个模块的误差累积起来，是否会放大到不可接受的程度。</p></li></ul><p>1）理解集成测试定义和内容：</p><ul><li>掌握集成测试参考文档：主要依据概要设计文档</li><li>集成测试时间点：在单元测试之后，系统测试之前</li><li>集成测试的侧重点：重点测试接口或函数之间调用关系</li></ul><p>2）重点掌握以下几种最常用的集成测试策略：</p><ul><li>大爆炸集成策略—非增量式<ul><li>大爆炸集成是将所有经过单元测试的模块一次性组装到被测系统中进行测试，完全不考虑模块之间的依赖性和可能存在的风险。</li><li>大爆炸集成仅需一个测试用例， 达到用例规模的最小化。同时，由于将所有模块包含进来，不涉及驱动模块和桩模块的开发工作。然而，该测试用例包含所有模块的接口，直接导致缺陷定位的困难。一旦用例失败，完全不知道是哪对模块的调用接口（在涉及模块和接口数量不多的情况下，小范围的大爆炸集成仍然是可行的，或者是比较稳定的版本，只是对其进行了修改也可以使用）</li></ul></li><li>自顶向下集成策略—增量式<ul><li>自顶向下的集成测试策略是从主控模块(主程序,即根结点)开始，按照系统程序结构，沿着控制层次从，上而下，逐浙将各模块组装起来。</li><li>可以使用宽度优先或深度优先</li><li>深度优先实例如下：</li></ul></li></ul><p><img src="/2020/06/20/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5/1592704657385.png" alt="深度优先"></p><ul><li><p>自顶向下集成测试策略适用于:<br>➢产品控制结构比较清晰和稳定;<br>➢高层接口变化较小;<br>➢底层接口未定义或经常可能被修改;<br>➢产品组件具有较大的技术风险，需要尽早被验证;<br>➢希望尽早能看到产品的系统功能行为。</p></li><li><p>自底向上集成策略—增量式</p><ul><li>自底向 上的集成测试策略是从最底层模块(即叶子结点)开始，按照调用图的结构，从下而上，逐层将各模块组装起来。（需要驱动模块）</li><li>实例：先测试最底层（提供驱动模块），然后依次的向上进行测试<br><img src="/2020/06/20/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5/1592704853847.png" alt="自底向上集成策略"></li><li>自底向上的集成测试策略适用于: .<br>➢底层接口比较稳定;<br>➢高层接口变化比较频繁;<br>➢底层组件较早被完成。</li></ul></li><li><p>三明治集成策略—增量式</p><ul><li>“三明治”集成是将自顶向下和自底向上集成方法结合起来的集成策略。在调用图上按照定的策略，分别从项向下和自底向上展开集成，并在子树.上进行大爆炸集成。</li><li>步骤：<ul><li>①将系统划分为三层，中间层为目标层，测试时对目标层上面的层使用自顶向下的集成策略，对目标层下面的层使用自底向上的集成策略</li><li>②在①的基础上，对目标层采用独立测试的策略。</li><li>③对包含读操作的子系统自底向上集成测试直至根节点，对包含写操作的子系统自项向下集成测试直至叶子节点。</li></ul></li></ul></li></ul><p><img src="/2020/06/20/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5/1592705167527.png" alt="三明治集成策略"></p><h2 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h2><p>本章节理解内容较多，重点掌握以下内容：</p><ul><li><p>系统测试主要分为功能测试与非功能测试</p></li><li><p>重点掌握系统测试的分类</p><ul><li><p>功能测试  </p><ul><li>主要是根据产品的需求规格说明书和测试需求列表，验证产品是否符合产品的功能需求。</li></ul></li><li><p>性能测试     </p><ul><li><p>可从三个方面进行性能测试：应用在客户端性能的测试、应用在网络上性能的测试和应用在服务器端性能的测试。  </p></li><li><p>​     性能测试是涉及范围非常广的测试。压力测试、负载测试、强度测试、稳定性测试、健壮性测试、大数据量测试都和性能测试有密切关系  </p></li><li><p>性能测试指标：</p><ul><li><strong>响应时间</strong>：指客户端发出请求到得到服务器响应的整个过程的时间。</li></ul></li></ul></li></ul></li></ul><p><img src="/2020/06/20/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5/1592706979065.png" alt="响应时间"></p><ul><li><ul><li><p><strong>吞吐量</strong>：吞吐量是指在某个特定的时间单位内系统所处理的用户请求数量，它直接体现软件系统的性能承受力。</p></li><li><p><strong>并发用户数</strong>：并发用户数是指在某一给定时间内，在某个特定站点上进行公开会话的用户数目。</p><ul><li><p>严格并发：指所有的用户在同一时刻做同一件事或操作。</p></li><li><p>广义并发：多个用户对系统发出了请求或者进行了操作，但是这些请求或者操作可以是相同的，也可以是不同的。</p></li></ul></li><li><p><strong>系统资源利用率</strong>： 资源利用率是指系统不同资源（如：服务器的CPU、内存，网络带宽等）的使用程度，通常用占有资源的最大可用量的百分比来衡量  </p></li><li><p><strong>点击率：</strong>点击率指客户端每秒向Web服务器端提交的HTTP请求数量，这个指标是Web应用特有的一个指标。</p></li><li><p>​     <strong>思考时间</strong>  ：  思考时间也称为休眠时间，从业务的角度来说，这个时间指的是用户在进行操作时，每个请求之间的间隔时间  </p></li><li><p>​     <strong>HTTP</strong>请求出错率  ： HTTP请求出错率是指失败的请求数占请求总数的比例  </p></li><li><p><strong>性能计数器：</strong>      性能计数器描述服务器或操作系统性能的一些数据指标  </p></li></ul><p>压力测试</p><ul><li><p>压力测试又称强度测试，是在各种资源超负荷情况下观察系统的运行情况  </p></li><li><p>安全性测试</p><ul><li>安全性是指使伤害或损害的风险限制在可接受的水平内。  安全性测试的测试人员需要在测试活动中，模拟不同入侵方式攻击系统的安全机制，想尽一切办法来获取系统内的保密信息。  </li><li>安全性测试方法包括：功能验证、漏洞扫描和模拟攻击。</li><li>系统安全测试的内容：应用程序安全测试、操作系统安全测试、数据库安全、IIS服务器安全测试、网络环境安全测试。</li></ul></li><li><p>备份测试</p><ul><li>​     备份测试为了验证系统在软件或者硬件失败的事件中备份其数据的能力  </li></ul></li><li><p>健壮性测试</p><ul><li>​     健壮性测试又称容错性测试。主要是测试系统在出现故障时，是否能够自动恢复或者忽略故障继续运行 ，尤其要注意妥善地进行系统异常的处理。健壮性测试用例设计的常用方法有：系统故障插入测试，场景法，错误猜测法。  </li></ul></li><li><p>兼容性测试</p><ul><li>兼容测试将验证软件与其所依赖环境的依赖程度  </li></ul></li><li><p>可用性测试</p><ul><li>​     可用性测试是面向用户的系统测试。一般可用性测试包括对被测试系统的系统发布、系统功能、帮助  </li></ul></li><li><p>可安装性测试</p><ul><li>​        可安装性测试就是要验证成功安装系统的能力  </li></ul></li><li><p>用户文档测试</p><ul><li>​      用户文档一般包括<strong>用户操作手册、维护手册和在线帮助</strong>。文档测试是对系统提交给用户的文档进行验证，通过文档测试保证用户文档的正确性并使操作手册准确无误，提高系统的可维护性和可安装性  </li></ul></li></ul></li><li><p>了解系统测试常用的工具</p><ul><li><strong>功能测试工具</strong>：     Quick Test Professional（QTP）[制定测试计划—&gt;创建测试脚本—&gt;增强测试脚本功能—&gt;运行测试—&gt;分析测试结果]，Rational Functional tester和Selenium  </li><li><strong>性能测试工具</strong>    HP  LoadRunner       WAS       IBM Performance Tester       Jmeter       OpenSTA       AB  </li></ul></li></ul><p>定义：一般而言，系统测试是将已经集成好的软件系统作为计算机系统的一个元素，与计算机硬件、外设、某些支持软件、数据和人员等其它系统元素结合在一起，在实际运行（使用）环境下，对计算机系统进行一系列的组装测试和确认测试，实际上是对被测系统的各个组成部分进行综合检验。   </p><p>​      系统测试应由测试组长组织  </p><p>系统测试的过程：</p><p>​     计划阶段、用例分析和设计阶段、实施阶段、执行阶段和分析评估阶段  </p><h2 id="验收测试"><a href="#验收测试" class="headerlink" title="验收测试"></a>验收测试</h2><p><strong>验收测试(Acceptance Test</strong>):在软件产品完成了系统功能和非功能测试之后、产品发布之前所进行的软件测试活动它是技术测试的最后 一个阶段，也称为交付测试。</p><p>验收测试是交付给客户之前的最后一次全面的测试，需掌握以下内容：</p><ul><li>重点掌握验收测试都包含哪些内容，如安装测试、文档测试、界面测试等。<ul><li>验证系统是否达到了用户需求规格说明书(可能包括项目或产品验收准则)中的要求，测试尽可能地发现软件中存留的缺陷，从而为软件进一步改善提供帮助，并保证系统或软件产品最终被用户接受。主要包括易用性测试、安装测试、文档(如用户手册)测试等几个方面的内容</li></ul></li><li>验收测试分类<ul><li>α测试<ul><li>a测试是指软件开发公司组织内部人员模拟各类用户行对即将面市软件产品(称为a版本)进行测试，试图发现错误并修正（经过修整之后变成β版本）</li></ul></li><li>β测试<ul><li>β测试是指软件开发公司组织各方面的典型用户在日常工作中实际使用β版本，并要求用户报告异常情况、提出批评意见。然后软件开发公司再对β版本进行改错和完善</li></ul></li></ul></li><li>验收测试需要准备的清单</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>测试粒度不同</strong>：</p><p>单元测试粒度最小</p><p>集成测试粒度居中</p><p>系统测试粒度最大</p><p><strong>测试方法不同</strong>：</p><p>集成测试一般由开发小组采用白盒加黑盒的方式来测试;</p><p>单元测试一般由开发小组采用白 盒方式来测试;</p><p>系统测试一般由独立测试小组采用黑盒方式来测试。</p><p><strong>测试内容不同</strong>：</p><p>集成测试既验证“设计”，又验证“需求”;</p><p>单元测试主要测试单元是否符合“设计”:</p><p>系统测试主要测试系统是否符合“需求规格说明书”</p><p><strong>测试阶段不同</strong>：</p><p>单元测试为开发人员在开发阶段要做的事情;</p><p>集成测试为开发人员在测试周期内级层做的工作;</p><p>系统测试为测试人员在测试周期内级层做的工作。</p><p><img src="/2020/06/20/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5/1592707786170.png" alt="测试的区别"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="软件测试" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>黑盒测试</title>
    <link href="http://yoursite.com/2020/06/18/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2020/06/18/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/</id>
    <published>2020-06-18T08:58:08.000Z</published>
    <updated>2020-06-19T09:07:12.270Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>定义</strong>：只知道系统输入和预期输出，不需要了解程序内部结构和内部特性的测试方法就称为黑盒测试。</p><p><strong>黑盒测试的优势</strong>：</p><ul><li><p>方法简单有效</p></li><li><p>可以整体测试系统的行为</p></li><li><p>开发与测试可以并行</p></li><li><p>对测试人员技术要求相对较低</p></li></ul><p><strong>黑盒测试的经济学问题</strong>：</p><ul><li>通过测试无法证明，被测软件系统是没有缺陷的。</li></ul><p><strong>黑盒测试的评价标准</strong>：</p><p>在最短时间内，以最少的人力，有利于发现最多的，以及最严重的缺陷。</p><ul><li><p>精确的:测试针对性强（设计测试用例的数量越少越好）</p></li><li><p>完备的:测试覆盖全面，无漏洞</p></li><li><p>无冗余</p></li><li><p>简单的:测试方法简单易行</p></li><li><p>易于调试:缺陷定位难度小</p></li></ul><h2 id="等价类测试"><a href="#等价类测试" class="headerlink" title="等价类测试"></a>等价类测试</h2><p><strong>基本原理：</strong></p><p>输入的数据不同，但是的到的结果是相同的，也就是输入x,y则F(x) = F(y)，这就是一个等价类</p><p><strong>等价类的划分</strong></p><p>输入测试:划分有效等价类、效等价类.</p><p>输出测试:有效等价类(通常只针对有效等价类进行设计)</p><ul><li><p>有效等价类</p><ul><li>有效等价类对应有效输入域的数据</li><li>有效等价类设计的测试用例用于检验被测系统是否能够正确完成指定功能</li></ul></li><li><p>无效等价类</p><ul><li>无效等价类则对应无效输入域中的数据</li><li>无效等价类设计的测试用例被用来考察.被测系统的容错性</li></ul></li></ul><p><strong>等价类的测试流程</strong>：</p><ul><li><p>确定有几类输出结果</p></li><li><p>对每类输出结果划分等价类.</p></li><li><p>划分等价后,建立等价类表,妫每个等价类规定-一个唯一 的编号;</p></li><li><p>设计一个测试用例，使其尽可能多地覆盖尚未被覆盖地有效等价类,蝮这-步骤, 直到所有的有效等价类都被覆盖为止;</p></li><li><p>设计-个新的测试用例，使其仅覆盖-个尚未被覆盖的无效等价类, 蝮这-步骤,直到所有的无效等价类都被覆盖为止。</p></li></ul><h2 id="边界值测试"><a href="#边界值测试" class="headerlink" title="边界值测试"></a>边界值测试</h2><p><strong>定义</strong>：</p><p>在输入输出变量范围的边界上，验证系统功能是否正常运行的测试方法。</p><p><strong>输出域的测试用例设计流程</strong>：</p><ul><li><p>确定有几类输出结果;</p></li><li><p>确定每类输出结果的边界点;</p></li><li><p>划定边界邻域delta;</p></li><li><p>每个边界对应3个测试数据;</p></li><li><p>单边界设计测试用例。</p></li></ul><h2 id="等价类边界值案例"><a href="#等价类边界值案例" class="headerlink" title="等价类边界值案例"></a>等价类边界值案例</h2><p>题目：</p><p> 某网站注册邮箱时，邮箱名要求6~18个字符，可使用字母、数字、下划线，需以字母开头。试用等价类设计测试用例，并用边界值进行补充测试用例。要求按照写明等价类分类及编号，以及边界值的分类和编号。测试用例要求有编号、输入数据、预期结果，覆盖等价类或边界值编号等信息 </p><p>分析：</p><ul><li>先设计等价类表（确定哪些是有效等价类，哪些是无效的等价类）</li><li>设计边界值的分类表</li><li>设计测试用例（覆盖所有的等价类以及边界值）</li></ul><p>答案：</p><p><img src="/2020/06/18/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/1592526063873.png" alt="等价类边界值"></p><h2 id="决策表法"><a href="#决策表法" class="headerlink" title="决策表法"></a>决策表法</h2><p><strong>概述</strong>：</p><p>决策表(Decision Table)，又叫判定表是分析和表达多逻辑条件下执行不同操作的工具。在程序设计发展的初期，判定表被当作编写程序的辅助工具。</p><p><strong>适用场景：</strong></p><p>但是如果输入条件之间设立了一些规则，或者输入条件之间有逻辑关系，考虑决策表。</p><p><strong>具体步骤</strong>: </p><p>列出条件桩和动作桩;</p><p>确定规则个数:假如有n个条件，每个条件有两个取值，则有2”种规则;</p><p>输入条件项和动作项，得到初始决策表;</p><p>简化决策表(原则:有两条或多条规则具有相同动作，并且条件项之间存在着极为相似的关系，合并)</p><p>根据决策表设计测试用例</p><p><strong>决策表的构成</strong></p><p>条件桩:列出了问题的所有条件。</p><p>条件项:针对条件桩给出的条件列出所有可能的取值。</p><p>必动作桩:给出了问题规定的可能采取的操作。</p><p>必动作项:和条件项紧密相关，指出在条件项的各组取值情况下应采取的动作。</p><p>实例：</p><p><img src="/2020/06/18/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/1592526785902.png" alt="决策表"></p><p><strong>决策表的简化</strong>：</p><p>有两条或多条规则具有相同的动作，并且其条件项之间存在着极为相似的关系，就可以将规则合并。</p><p>例如：上图中的1和2,他的动作都是A4，并且他的条件C1和C2都为T，无论C3是T还是F都不影响动作，因此可以将其进行合并.</p><p>实例：</p><p><img src="/2020/06/18/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/1592527005349.png" alt="化简"></p><p>根据这一个化简的方法，可以得出下面这个已经化简的决策表：</p><p><img src="/2020/06/18/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/1592527113205.png" alt="化简之后的决策表"></p><h2 id="因果图法"><a href="#因果图法" class="headerlink" title="因果图法"></a>因果图法</h2><p>4中符号：</p><p>因果图中使用了简单的逻辑符号，以直线连接左右节点。左节点表示输入状态(或称原因)，右节点表示输出状态(或称结果)。</p><ul><li>恒等：原因为1，则结果也为1</li><li>非：原因为1，则结果为0</li><li>或：原因都为1,则结果为1；否则结果为0</li><li>与：原因有一个为1，结果为1；如果都为0，则为0</li></ul><p><img src="/2020/06/18/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/1592527851214.png" alt="恒等和非"></p><p><img src="/2020/06/18/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/1592528376368.png" alt="或 与"></p><p><strong>输入条件约束</strong></p><p>E约束（互斥）：原因a和原因b不会同时成.工，两个中最多有一个可能成立。</p><p><img src="/2020/06/18/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/1592529453599.png" alt="E约束"></p><p>I约束（包含）：a、b、c这三个原因中至少有一个必须成立。</p><p><img src="/2020/06/18/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/1592529530445.png" alt="I约束"></p><p>o约束（唯一） ：原因a和b中必须有一个，且仅有一个成立。</p><p><img src="/2020/06/18/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/1592529922992.png" alt="o约束"></p><p>R约束（要求）:原因a出现时，原因b也必须出现，a出现时，不可能b不出现。</p><p><img src="/2020/06/18/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/1592530015381.png" alt="R约束"></p><p><strong>输出条件的约束</strong></p><p>M约束（屏蔽或强制）：结果a为1，则结果b值为0。当a为0,b的值不确定。</p><p><img src="/2020/06/18/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/1592530132128.png" alt="M约束"></p><p>因果图设计测试用例：</p><ul><li>根据题目判断出原因和结果</li><li>根据原因和结果写出因果图</li><li>根据因果图写出决策表</li><li>根据决策表设计测试用例</li></ul><h2 id="正交表"><a href="#正交表" class="headerlink" title="正交表"></a>正交表</h2><p> 正交表是一种特制的表格，一般用Ln(mk)表示，L代表是正交表，n代表试验次数或正交表的行数（测试用例的个数），k代表最多可安排影响指标因素的个数或正交表的列数，m表示每个因素水平数，且有n=k*(m-1)+1。</p><p>（1）因素（Factors）。表示在一项试验中，需要观察的变量称为因素。</p><p>（2）水平位（（Levels）。表示在试验范围内，因素被考察的值称为水平位（变量的取值）</p><p>（3）正交表的组成。由行数（正交表的行的个数，即试验的次数）、因素数（正交表列的个数）、水平数（任何单个因素能够取得的值得最大个数）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="软件测试" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Spring5</title>
    <link href="http://yoursite.com/2020/06/17/Spring5/"/>
    <id>http://yoursite.com/2020/06/17/Spring5/</id>
    <published>2020-06-17T02:37:10.000Z</published>
    <updated>2020-06-19T09:06:53.609Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Spring5"><a href="#Spring5" class="headerlink" title="Spring5"></a>Spring5</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>（1）Spring是一个轻量级的开源的JavaEE的框架</p><p>（2）Spring可以解决企业开发应用的复杂性</p><p>（3）Spring有两个核心部分：IOC和AOP</p><ul><li>IOC:控制反转：把创建对象的过程交给Spring进行管理</li><li>AOP:面向切面编程，不修改源代码进行功能的增强</li></ul><p>（4）Spring的特点：</p><ul><li>方便解耦，简化开发</li><li>方便程序的测试</li><li>Aop的支持</li><li>方便整合其他的框架</li><li>方便进行事务的操作</li><li>降低了API的开发难度</li></ul><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>（1）下载Jar包</p><ul><li><p>先到官网下载jar包   <a href="https://repo.spring.io/release/org/springframework/spring/" target="_blank" rel="noopener">https://repo.spring.io/release/org/springframework/spring/</a> </p></li><li><p>选取最新的点击下载就可以了</p></li></ul><p>（2）创建工程，选取jar包</p><p>下面是Spring的基础包：</p><p><img src="/2020/06/17/Spring5/1592362693529.png" alt="jar包"></p><p>另外还需要一个日志包进行对日志的相关记录：</p><ul><li>commons-logging-1.2.jar</li></ul><p>将上面的jar包进行导入</p><p>（3）创建一个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"这个是user类"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4)创建配置类</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置User对象的创建--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.bean.User"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(5)创建测试类进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//加载配置文件</span></span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean1.xml"</span>);</span><br><span class="line">    <span class="comment">//获取配置中创建的对象</span></span><br><span class="line">    User user = context.getBean(<span class="string">"user"</span>, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    user.add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h2><h3 id="IOC的概念和原理"><a href="#IOC的概念和原理" class="headerlink" title="IOC的概念和原理"></a>IOC的概念和原理</h3><p>（1）概念：控制反转，把对象的创建和对象之间的调用过程，交给spring进行管理。</p><p>（2）使用IOC的目的：为了耦合度的降低</p><p>（3）IOC的底层原理：</p><ul><li>XML解析</li><li>工厂模式<ul><li>就是利用一个工厂类来解耦两个类</li><li>实例：当UserService想要创建UserDao类的时候，不需要直接new，通过UserFactory类来获取UserDao</li><li><img src="/2020/06/17/Spring5/1592401410337.png" alt="1592401410337"></li></ul></li><li>反射</li></ul><p>（4）IOC的实现过程</p><ul><li>先在XML配置相关的文件，配置创建的对象</li><li>根据配置文件创建工厂类（通过反射）<ul><li>先解析xml文件获取类的名称</li><li>通过反射获取该类的Class文件</li><li>通过newInstance方法获取该类并进行强制转换</li><li>最后将该类返回</li></ul></li></ul><p><img src="/2020/06/17/Spring5/1592550369004.png" alt="IOC的实现过程"></p><p>(5)IOC思想基于IOC容器完成，IOC容器底层就是对象工厂</p><p>(6)Spring提供IOC容器实现两种方式：（两个接口）</p><ul><li>BeanFactory：IOC容器基本实现（Spring内部使用的接口，一般不提供给开发人员使用）<ul><li>加载配置文件的时候不会创建配置文件中的对象，在获取对象才会创建对象</li></ul></li><li>ApplicationContext：BeanFactory接口的子接口，提供更多强大的功能，一般由开发人员进行使用<ul><li>加载配置文件的时候就会把配置文件中的对象进行创建</li></ul></li></ul><p>一般会使用ApplicationContext</p><p>（7）ApplicationContext中的一些实现类</p><p><img src="/2020/06/17/Spring5/1592552079903.png" alt="ApplicationContext的实现类"></p><p>FileSystemXmlApplicationContext：对应配置文件（XML）的磁盘中的位置</p><p>ClassPathXmlApplicationContext：对应src下面配置文件的位置</p><h3 id="IOC操作Bean管理"><a href="#IOC操作Bean管理" class="headerlink" title="IOC操作Bean管理"></a>IOC操作Bean管理</h3><h4 id="Bean管理概述"><a href="#Bean管理概述" class="headerlink" title="Bean管理概述"></a>Bean管理概述</h4><p>Bean管理指的是两个操作：</p><p>（1）Spring创建对象:由Spring代替我们创建对象，我们只需要在xml进行配制</p><p>（2）Spring注入属性:Spring可以向配置的类中注入相关的属性的值</p><p>Bean管理的 实现方式：</p><p>（1）基于Xml配置文件方式实现</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置User对象的创建--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.bean.User"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>id：获取对象的标识（唯一）</li><li>class：全类名，指定需要配置的类</li><li>name：和id的作用是一样的，区别：name里面可以添加一些特殊的符号（/等）一般不用</li></ul><p>在创建对象的时候默认是<strong>使用无参数的构造器</strong></p><p>（2）基于注解方式实现</p><p>DI:依赖注入（注入属性）这是IOC的一种具体实现，表示依赖注入，这个需要在创建对象的基础之上进行完成。（先创建对象后注入属性）</p><p> 第一种注入的方式：通过类本身的set方法进行注入</p><ul><li>创建一个类，并创建set 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  String bname;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBname</span><span class="params">(String bname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bname = bname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Spring的配置文件中配置对象的创建，在对属相进行注入</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    1.先创建对象</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">"book"</span> <span class="attr">class</span>=<span class="string">"com.bean.Book"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        使用property完成属性的注入</span></span><br><span class="line"><span class="comment">            name:类里面的属性名称</span></span><br><span class="line"><span class="comment">            value:向属相内赋值</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"bname"</span> <span class="attr">value</span>=<span class="string">"易经经"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二种注入的方式：通过有参构造注入</p><ul><li>先创建一个类，并创建该类中的有参构造器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  String bname;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bname = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在Spring配置文件中进行配置</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">"book1"</span> <span class="attr">class</span> = <span class="string">"com.bean.Book"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">name:属性的名称</span></span><br><span class="line"><span class="comment">value:属性的名称</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"ss"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">index:有参构造器中第i+1个参数</span></span><br><span class="line"><span class="comment">value:该参数的值</span></span><br><span class="line"><span class="comment">&lt;constructor-arg index="i" value="ss"/&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="java,Spring" scheme="http://yoursite.com/tags/java-Spring/"/>
    
  </entry>
  
  <entry>
    <title>白盒测试</title>
    <link href="http://yoursite.com/2020/06/16/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2020/06/16/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/</id>
    <published>2020-06-16T02:00:11.000Z</published>
    <updated>2020-06-19T09:07:06.083Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h1><h2 id="关注的对象"><a href="#关注的对象" class="headerlink" title="关注的对象"></a>关注的对象</h2><p>1.源代码</p><ul><li>措施:阅读源代码，检验代码的规范性,并对照函数功能查找代码的逻辑缺陷、内存管理缺陷、数据定义和使用缺陷等</li></ul><p>2.程序结构</p><ul><li>措施:使用与程序设计相关的图表，找到程序设计的缺陷，或评价程序的执行效率</li></ul><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul><li><p>针对性强，便于快速定位缺陷。</p></li><li><p>在函数级别开始测试工作，缺陷修复的成本低。</p></li><li><p>有助于了解测试的覆盖程度。</p></li><li><p>有助于代码优化和缺陷预防。</p></li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li><p>对测试人员要求高</p><ul><li>测试人员需要具备一定的编程经验白盒测试工程师需要具备广博的知识面</li></ul></li><li><p>成本高</p><ul><li>白盒测试准备时间较长</li></ul></li></ul><h2 id="白盒测试的经济学问题"><a href="#白盒测试的经济学问题" class="headerlink" title="白盒测试的经济学问题"></a>白盒测试的经济学问题</h2><ul><li><p>软件测试是不完备的</p></li><li><p>软件测试是有风险的</p></li><li><p>测试设计应达到的目标</p></li></ul><h2 id="逻辑覆盖"><a href="#逻辑覆盖" class="headerlink" title="逻辑覆盖"></a>逻辑覆盖</h2><h3 id="1-语句覆盖"><a href="#1-语句覆盖" class="headerlink" title="1.语句覆盖"></a>1.语句覆盖</h3><p><strong>定义</strong>：设计测试用例时，<strong>需要保证程序中每一条可执行语句至少应执行一次</strong>。（也就是点覆盖）.</p><p><strong>缺点</strong>：语句覆盖是最弱的一种覆盖标准，它主要存在两方面弊端。</p><ul><li>关注语句，而非关注判定节点。</li><li>对隐式分支无效。</li></ul><p>实例：</p><p>测试用例的执行路径覆盖了全部的节点。</p><p><img src="/2020/06/16/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/1592288092104.png" alt="语句覆盖"></p><h3 id="2-判定覆盖"><a href="#2-判定覆盖" class="headerlink" title="2.判定覆盖"></a>2.判定覆盖</h3><p><strong>定义</strong>：判定覆盖也称为分支覆盖;设计测试用例时，<strong>应保证程序中每个判定节点取得每种可能的结果至少一次</strong>。判定覆盖相当于对控制流图进行边覆盖。</p><p><strong>缺点</strong>：当判定节点中包含的是复合判定表达式时，即由多个简单判定条件通过“与”、“或关系连接而成的判定。此时，判定覆盖仅关心表达式的整体取值,并不关心表达式如何构成，不能覆盖到每个子条件的所有取值情况，由此导致测试的漏洞。</p><p>实例：</p><p>设计的测试用例将两个判定节点取真和取假都执行了一次。</p><p><img src="/2020/06/16/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/1592288200690.png" alt="判定覆盖"></p><h3 id="3-条件覆盖"><a href="#3-条件覆盖" class="headerlink" title="3.条件覆盖"></a>3.条件覆盖</h3><p><strong>定义</strong>：设计测试用例时，应保证程序中每个复合判定表达式中，每<strong>个简单判定条件的取真和取假情况至少执行一次</strong>。.</p><p>条件覆盖并不能确保满足判定覆盖，相比判定覆盖，条件覆盖虽然进一步深入检查了判定节点中的每个子条件，但判定节点局部的完全覆盖并不能保证对判定节点整体的完全覆盖。</p><p>实例：</p><p>每一个简单的判定条件的取真和取假的情况都执行了一次</p><p><img src="/2020/06/16/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/1592288300056.png" alt="条件覆盖"></p><h3 id="4-判定-条件覆盖"><a href="#4-判定-条件覆盖" class="headerlink" title="4.判定/条件覆盖"></a>4.判定/条件覆盖</h3><p><strong>定义</strong>：<strong>测试用例设计应满足判定节点的取真.取假分支至少执行一次，且每个简单判定条件的取真和取假情况也至少执行一次</strong>，即判定覆盖+条件覆盖。</p><h3 id="5-条件组合覆盖"><a href="#5-条件组合覆盖" class="headerlink" title="5.条件组合覆盖"></a>5.条件组合覆盖</h3><p><strong>定义</strong>：测试用例的设计应满足每个判定节点中，<strong>所有简单判定条件的所有可能的取值组合情况应至少执行一次</strong>。</p><p><strong>优势</strong>：方法简单;只需要找到所有简单条件，并列出真值表，穷尽所有组合情况即可。</p><p><strong>缺点</strong>：测试用例的冗余，而且一些条件不可能成立</p><h3 id="6-修正的判定-条件覆盖"><a href="#6-修正的判定-条件覆盖" class="headerlink" title="6.修正的判定/条件覆盖"></a>6.修正的判定/条件覆盖</h3><p><strong>基本思想</strong>:在满足判定/条件覆盖的基础上，每个简单判定条件都应独立地影响到整个判定表达式的值。<br><strong>实质</strong>:利用简单判定条件的独立影响性来消除测试用例的冗余。</p><p><strong>一般步骤：</strong></p><ul><li><p>列出所有的简单判定条件;</p></li><li><p>构建真值表;</p></li><li><p>对每个简单判定条件，找到能够对整个判定结果产生独立影响的测试用例集合(简称独立影响对) ;注意独立影响对可能不止一组。</p></li><li><p>具体措施是:抽取能体现所有简单判定条件独立影响性的最少独立影响对。</p></li></ul><p><strong>优势：</strong>综合具备条件组合覆盖的优点，有效控制了测试用例数量，消除了测试冗余。<br><strong>不足：</strong>测试用例设计较为困难。</p><p>这6种覆盖策略，基本.上是按照由弱到强的程度来设计的，但也不是绝对的。比如，满足条件覆盖时，未必满足语句覆盖或判定覆盖。</p><h3 id="7-路径覆盖（补充）"><a href="#7-路径覆盖（补充）" class="headerlink" title="7.路径覆盖（补充）"></a>7.路径覆盖（补充）</h3><p><strong>定义：</strong>就是将程序中所有可能的路径都覆盖一次</p><h2 id="基本路径法"><a href="#基本路径法" class="headerlink" title="基本路径法"></a>基本路径法</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>基本路径测试方法是白盒测试最为典型的测试方法。</p><p>基本路径测试方法:在程序控制流图的基础上通过分析程序的圈复杂度，导出独立路径集合，从而设计测试用例的方法。</p><h3 id="2-控制流图"><a href="#2-控制流图" class="headerlink" title="2.控制流图"></a>2.控制流图</h3><p><img src="/2020/06/16/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/1592357916987.png" alt="控制流图"></p><p>在分支的汇聚的地方应该有也是一个节点</p><p>如果一个判定节点里面有多个简单的判定条件，如要改成单条件的嵌套判断</p><p>节点的序号最好使用代码的行号进行表达。</p><p><img src="/2020/06/16/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/1592358468630.png" alt="控制流图和代码"></p><h3 id="3-计算复杂度"><a href="#3-计算复杂度" class="headerlink" title="3.计算复杂度"></a>3.计算复杂度</h3><p><strong>定义：</strong>圈复杂度是一-种为程序逻辑复杂性提供定量测度的软件度量，将该度量用于计算程序的基本的独立路径数目，为确保所有语句至少执行一次的测试数量的上界。独立路径必须包含一条在其它独立路径中不曾用到的边。【圈复杂度==独立路径的数量】</p><p>有以下三种方法计算圈复杂度:</p><ul><li><p>流图中封闭区域的数量+1个开放区域=总的区域数=圈复杂度(注:边和结点圈定的区域叫做区域，当对区域计数时， 图形外的区域也应记为一个区域。)</p></li><li><p>给定流图G的圈复杂度V(G)，定义为V(G)= E-N+2,E是流图中边的数量，N是流图中结点的数量;</p></li><li><p>给定流图G的圈复杂度V(G)，定义为V(G)= P+1, P是流图G中判定结点的数量。</p></li></ul><h3 id="4-独立路径"><a href="#4-独立路径" class="headerlink" title="4.独立路径"></a>4.独立路径</h3><p>定义：独立路径是指，和其他的独立路径相比，至少引入一个新处理语句或一个新判断的程序通路。【就是每一个独立路径都是不相同的（从起点到终点的路径）】</p><p>圈复杂度的值正好等于该程序的独立路径的条数。</p><p>比如：</p><p>可以看出每一个路径都是不一样的。</p><p><img src="/2020/06/16/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/1592358987349.png" alt="独立路径"></p><h3 id="5-编写测试用例"><a href="#5-编写测试用例" class="headerlink" title="5.编写测试用例"></a>5.编写测试用例</h3><p>设计出的测试用例要保证独立路径集合中每条路径至少执行一次。[有多少个独立路径就涉及多少个测试用例]</p><p>比如：</p><p>一个测试用例包括一个独立路径</p><p><img src="/2020/06/16/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/1592359181111.png" alt="根据独立路径编写测试用例"></p><h2 id="静态白盒测试"><a href="#静态白盒测试" class="headerlink" title="静态白盒测试"></a>静态白盒测试</h2><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h3><p>软件测试不仅包括动态测试，还包括对系统的静态检查，这种检查通常不需要实际运行被测软件，而是直接对软件形式和结构进行分析。</p><h3 id="2-代码检查"><a href="#2-代码检查" class="headerlink" title="2.代码检查"></a>2.代码检查</h3><p>代码检查主要是通过同行评审来发现缺陷;以评审会议为形式，通过多人对软件交付物进行检查，从而发现缺陷，或者获得改进优化的机会;同行评审往往需要大量投入时间和人力资源。</p><p>同行评审的核心：缺陷预防</p><p>目的：发现缺陷，改进开发过程</p><p>同行评审方法【前三个比较正规，后三个比较随意】：</p><ul><li><p>审查(Inspection)</p></li><li><p>团队评审(Team Review)</p></li><li><p>走查(Walk Through)</p></li><li><p>结对编程(Pair Programming)</p></li><li><p>同行桌查(Peer Desk Check)</p></li><li><p>轮查(Pass Around)</p></li><li><p>特别检查(Ad hoc Review)</p><p>评审的过程：</p></li></ul><p><img src="/2020/06/16/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/1592359730000.png" alt="1592359730000"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>白盒测试方法综合应用策略：</strong></p><p><strong>（1）开始进行白盒测试时，首先应当尽量使用测试工具进行程序静态结构分析。</strong></p><p><strong>（2）在测试中，建议采用先静态后动态的组合方式。先进行静态结构分析和代码检查，然后再进行覆盖测试。</strong></p><p><strong>（3）利用静态分析的结果作为依据和引导，再使用代码检查和动态测试的方式对静态测试分析结果进行进一步确认，使测试工作更为准确和有效。</strong></p><p><strong>（4）覆盖率测试是白盒测试的重点，是测试报告中可以作为量化指标的依据。一般可以使用基本路径测试法达到语句覆盖的标准，对于重点模块应当使用多种覆盖率标准衡量代码的覆盖率。</strong></p><p><strong>（5）在不同的测试阶段，白盒测试的应用侧重点也不同。单元测试以代码检查和逻辑覆盖为主，集成测试需要增加静态结构分析等，而系统测试需要根据黑盒测试结果采取相应的白盒测试。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="软件测试" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>软件测试</title>
    <link href="http://yoursite.com/2020/06/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2020/06/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/</id>
    <published>2020-06-14T06:27:41.000Z</published>
    <updated>2020-06-19T09:07:18.778Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="软件测试——基本知识"><a href="#软件测试——基本知识" class="headerlink" title="软件测试——基本知识"></a>软件测试——基本知识</h1><h2 id="软件测试的定义"><a href="#软件测试的定义" class="headerlink" title="软件测试的定义"></a>软件测试的定义</h2><p>​        <strong>软件测试是人工的或通过使用工具来自动的运行被测软件系统，或静态检查被测系统的过程，其目的在于校验被测系统是否满足需求，或要弄清楚实际的 系统输出与预期系统输出的差异。</strong></p><p><img src="/2020/06/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/ruanjianceshidingyi.png" alt="软件测试"></p><p>​        从中可以看出<strong>软件测试的目的是确保被测系统满足用户需求。</strong></p><ul><li><p>软件测试以需求为中心。</p></li><li><p>软件测试包括动态测试和静态检查两类方法</p></li><li><p>测试的执行包括人工和自动化两类策略</p><p>动态（手工）测试：</p><ul><li>提供被测对象</li><li>准备相关的预期（文档）</li><li>设计测试用例</li><li>搭建测试环境</li><li>运行测试用例</li><li>检查测试结果</li><li>记录测试的过程</li><li>报告缺陷</li><li>回归测试</li><li>交付的文件：测试用例，驱动/桩模块，缺陷报告</li></ul><p>静态测试：</p><ul><li><p>提供被测对象（源代码）</p></li><li><p>准备相关的预期（文档）</p></li><li><p>阅读代码和文档</p></li><li><p>报告缺陷</p></li><li><p>回归测试</p></li></ul><p>自动化测试：</p><ul><li>提供被测对象</li><li>准备相关的预期（文档）</li><li>设计测试用例（编写测试脚本）</li><li>搭建测试环境（增加了对测试环境的配置）</li><li>运行测试用例</li><li>检查测试结果</li><li>记录测试的过程</li><li>报告缺陷</li><li>回归测试</li><li>交付的文件：测试用例，驱动/桩模块，缺陷报告，测试脚本</li></ul></li></ul><h2 id="软件测试的流程"><a href="#软件测试的流程" class="headerlink" title="软件测试的流程"></a>软件测试的流程</h2><h3 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h3><p>​        回答哪些人分别在什么时候使用哪些方法，利用哪些资源，遵循哪些标准，对系统中的哪些对象进行测试，在这个过程中可能存在哪些风险。</p><ul><li><p>输入</p><ul><li><p>需求规格说明</p></li><li><p>项目计划</p></li></ul></li><li><p>输出</p><ul><li>测试计划</li></ul></li></ul><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>​        根据用户的寻求、系统设计文档和测试计划，设计测试用例和测试过。</p><ul><li><p>输入</p><ul><li><p>需求</p></li><li><p>设计文档</p></li><li><p>测试计划</p></li></ul></li><li><p>输出</p><ul><li>测试用例</li><li>测试过程</li></ul></li></ul><h3 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h3><p>​        回答如何让测试用例跑起来，被测软件中发现了什么问题。根据测试用例设计模块，手工执行，或者根据测试用例编写测试脚本并运动，检查每一个结果，发现缺陷后提交缺陷报告。</p><ul><li><p>输入</p><ul><li><p>需求</p></li><li><p>测试用例</p></li><li><p>测试过程</p></li></ul></li><li><p>输出</p><ul><li>测试驱动模块</li><li>测试桩模块</li><li>测试脚本（可选）</li></ul></li></ul><h3 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h3><p>​    评估测试工作和被测系统，目的是回答测试工作质量怎么样，被测系统质量怎么样。</p><ul><li><p>输入</p><ul><li><p>缺陷报告</p></li><li><p>测试用例</p></li><li><p>测试标准</p></li></ul></li><li><p>输出</p><ul><li>测试评估报告</li></ul></li></ul><h2 id="软件缺陷"><a href="#软件缺陷" class="headerlink" title="软件缺陷"></a>软件缺陷</h2><h3 id="软件缺陷的定义"><a href="#软件缺陷的定义" class="headerlink" title="软件缺陷的定义:"></a>软件缺陷的定义:</h3><p><img src="/2020/06/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%BD%AF%E4%BB%B6%E7%BC%BA%E9%99%B7" alt="软件缺陷"></p><p><strong>1.软件测试人员认为软件难以理解、不易使用、运行速度缓慢，或者最终用户认为不好就是缺陷。</strong></p><p><strong>2.软件未达到需求规格说明书中指明的功能，就是缺陷</strong>。</p><ul><li>保证实现有效输入下的基本功能；</li><li>保证达到相关性能指标</li></ul><p><strong>3.软件出现了需求规格说明书中指明不会出现的错误，就是缺陷（这可视为对软件系统容错性的要求【容错性主要是依赖于测试人员的经验】）。</strong></p><ul><li>系统能否处理异常情况</li><li>系统能否识别用户输入的无效数据</li><li>系统能否处理用户无效的输入数据</li></ul><p><strong>4.软件功能超出需求规格说明书中指明的范围，就是缺陷</strong></p><ul><li>程序员错误的实现了需求规定的功能</li><li>需求规格说明有遗漏，但是程序员完成了</li><li>人为加入的一些超出需求规格说明书的功能（意外或者病毒）</li></ul><p><strong>5.软件未达到需求规格说明书中虽然没有指出，但是应该达到的目标，就是缺陷</strong></p><ul><li>软件的一些隐含的特性（一些对于异常的处理，或者与用户相关专业有关）</li></ul><h2 id="软件质量"><a href="#软件质量" class="headerlink" title="软件质量"></a>软件质量</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><img src="/2020/06/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/1592202129652.png" alt="软件质量"></p><p>质量：反映实体满足明确或隐含需要能力的特性总和</p><p>质量的三要素：</p><ul><li><p>实体</p><ul><li>实体是质量的主体，即测量的主体。-般指产品，也可以是活动、过程、组织、人，或者它们的组合。</li></ul></li><li><p>特性集合</p><ul><li>表示度量，特性必须可以测量，定性或定量方式得到指导性结论。</li></ul></li><li><p>需求</p></li></ul><p><strong>软件质量：反应软件满足明确或隐含能力的特性总和。</strong></p><p>​    客观而言，软件质量是软件具有某种能力的属性，这是前提条件<br>​    主观而言，软件具有的能力对应不同层次的用户需求</p><ul><li>侠义的软件质量：软件的内部质量，即软件无故障。</li><li>广义的软件质量：产品质量、过程质量和客户满意度。</li></ul><p><strong>软件测试不能提高软件质量，提高软件质量必须依靠改进软件开发过程的质量。</strong></p><p>软件质量的特性：</p><ul><li>功能性、可靠性、易用性、效率、可移植、可维护 </li></ul><h2 id="软件测试的分类"><a href="#软件测试的分类" class="headerlink" title="软件测试的分类"></a>软件测试的分类</h2><p>1、<strong>按照测试目标分类</strong>:可以分为功能测试、性能测试、可靠性测试、安全性测试、易用性测试等。</p><ul><li><p>功能测试: 针对软件功能需求进行测试，目的是检查应用程序的行为是否符合预期。</p></li><li><p>性能测试: 用于验证系统是否满足规格说明的性能需求，例如容量和响应时间等。</p><p>……</p></li></ul><p>2、<strong>按照执行方式分类</strong>:可以分为静态测试与动态测试。</p><ul><li>静态测试:不执行被测对象，通过检查、阅读进行分析。</li><li>动态测试:运行被测对象，通过观察运行过程进行验证。</li></ul><p>3、<strong>按照测试方法分类</strong>:可以分为白盒测试、黑盒测试、灰盒测试。</p><ul><li>黑盒测试关注的是与产 品的外部行为相关的缺陷，此时并不考虑产品的内部结构或运行逻辑。</li><li>白盒测试关注的是 与代码内部结构相关的缺陷，因此，需要测试人员掌握一定的编程技术。</li><li>灰盒测试是综合运用黑 盒测试和白盒测试技术的一种混合测试方法。</li></ul><p>4、<strong>按照测试阶段分类</strong>:可以分为单元测试、集成测试、系统测试、验收测试四个测试阶段。（V模型）</p><ul><li>单元测试用于验证一个单元模块(或组件)的功能是否正常，一个单元模块可以包括几行或上百行代码。（主要采用白盒测试）</li><li>集成测试是将不同的单元模块组合在一起，形成更大组件的测试过程。</li><li>系统测试用于检验软件产品是否能与系统的其它部分协调工作，包括硬件、数据库及操作人员等。</li><li>验收测试是软件部署之前的一个测试操作，其测试范围类似于系统测试，通常是由系统提供者和客户来共同完成。以确定系统是否满足验收标准</li></ul><h2 id="软件测试过程模型"><a href="#软件测试过程模型" class="headerlink" title="软件测试过程模型"></a>软件测试过程模型</h2><h3 id="V模型"><a href="#V模型" class="headerlink" title="V模型"></a>V模型</h3><p>V模型是最早提出来的测试模型，旨在改进软件的效率和效果。</p><p><img src="/2020/06/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/1592203424906.png" alt="V模型"></p><p>V模型的局限性：没有明确说明早期检测的重要性，不能提现“尽早开展测试的原则”</p><h3 id="W模型"><a href="#W模型" class="headerlink" title="W模型"></a>W模型</h3><p><img src="/2020/06/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/1592203570161.png" alt="W模型"></p><p><strong>W模型的价值和意义</strong>：</p><ul><li>注重在软件开发的各个阶段应用静态测试技术，使得在执行开发过程的同时执行测试,实现了真<br>正的开发与测试并行。</li><li>强调尽早展开测试，能够在开发早期发现缺陷,降低缺陷修改成本。</li></ul><p><strong>W模型的局限性:</strong></p><ul><li>将软件开发阶段视为串行活动,无法有效支持迭代及变更调整。</li></ul><h3 id="H模型"><a href="#H模型" class="headerlink" title="H模型"></a>H模型</h3><p><img src="/2020/06/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/1592203751602.png" alt="H模型"></p><h3 id="模型总结："><a href="#模型总结：" class="headerlink" title="模型总结："></a>模型总结：</h3><p>V模型的含义：强调了测试阶段划分,测试阶段与开发阶段的对应性<br>W模型的含义：强调了早期测试、静态测试的重要性<br>H模型的含义：强调了测试活动是独立的,与其他流程并发进行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="软件测试" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/06/04/hello-world/"/>
    <id>http://yoursite.com/2020/06/04/hello-world/</id>
    <published>2020-06-04T07:13:57.580Z</published>
    <updated>2020-06-04T07:13:57.580Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
