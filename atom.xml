<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>皮之鲲</title>
  
  <subtitle>总不能还没努力就向生活妥协</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-17T13:45:08.341Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>皮皮鲲</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring5</title>
    <link href="http://yoursite.com/2020/06/17/Spring5/"/>
    <id>http://yoursite.com/2020/06/17/Spring5/</id>
    <published>2020-06-17T02:37:10.000Z</published>
    <updated>2020-06-17T13:45:08.341Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Spring5"><a href="#Spring5" class="headerlink" title="Spring5"></a>Spring5</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>（1）Spring是一个轻量级的开源的JavaEE的框架</p><p>（2）Spring可以解决企业开发应用的复杂性</p><p>（3）Spring有两个核心部分：IOC和AOP</p><ul><li>IOC:控制反转：把创建对象的过程交给Spring进行管理</li><li>AOP:面向切面编程，不修改源代码进行功能的增强</li></ul><p>（4）Spring的特点：</p><ul><li>方便解耦，简化开发</li><li>方便程序的测试</li><li>Aop的支持</li><li>方便整合其他的框架</li><li>方便进行事务的操作</li><li>降低了API的开发难度</li></ul><h2 id="2-入门"><a href="#2-入门" class="headerlink" title="2.入门"></a>2.入门</h2><p>（1）下载Jar包</p><ul><li><p>先到官网下载jar包   <a href="https://repo.spring.io/release/org/springframework/spring/" target="_blank" rel="noopener">https://repo.spring.io/release/org/springframework/spring/</a> </p></li><li><p>选取最新的点击下载就可以了</p></li></ul><p>（2）创建工程，选取jar包</p><p>下面是Spring的基础包：</p><p><img src="/2020/06/17/Spring5/1592362693529.png" alt="jar包"></p><p>另外还需要一个日志包进行对日志的相关记录：</p><ul><li>commons-logging-1.2.jar</li></ul><p>将上面的jar包进行导入</p><p>（3）创建一个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"这个是user类"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4)创建配置类</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置User对象的创建--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.bean.User"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(5)创建测试类进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//加载配置文件</span></span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean1.xml"</span>);</span><br><span class="line">    <span class="comment">//获取配置中创建的对象</span></span><br><span class="line">    User user = context.getBean(<span class="string">"user"</span>, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    user.add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-IOC容器"><a href="#3-IOC容器" class="headerlink" title="3.IOC容器"></a>3.IOC容器</h2><h3 id="3-1-IOC的概念和原理"><a href="#3-1-IOC的概念和原理" class="headerlink" title="3.1 IOC的概念和原理"></a>3.1 IOC的概念和原理</h3><p>（1）概念：控制反转，把对象的创建和对象之间的调用过程，交给spring进行管理。</p><p>（2）使用IOC的目的：为了耦合度的降低</p><p>（3）IOC的底层原理：</p><ul><li>XML解析</li><li>工厂模式<ul><li>就是利用一个工厂类来解耦两个类</li><li>实例：当UserService想要创建UserDao类的时候，不需要直接new，通过UserFactory类来获取UserDao</li><li><img src="/2020/06/17/Spring5/1592401410337.png" alt="1592401410337"></li></ul></li><li>反射</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="java,Spring" scheme="http://yoursite.com/tags/java-Spring/"/>
    
  </entry>
  
  <entry>
    <title>白盒测试</title>
    <link href="http://yoursite.com/2020/06/16/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2020/06/16/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/</id>
    <published>2020-06-16T02:00:11.000Z</published>
    <updated>2020-06-17T02:15:47.559Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h1><h2 id="关注的对象"><a href="#关注的对象" class="headerlink" title="关注的对象"></a>关注的对象</h2><p>1.源代码</p><ul><li>措施:阅读源代码，检验代码的规范性,并对照函数功能查找代码的逻辑缺陷、内存管理缺陷、数据定义和使用缺陷等</li></ul><p>2.程序结构</p><ul><li>措施:使用与程序设计相关的图表，找到程序设计的缺陷，或评价程序的执行效率</li></ul><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul><li><p>针对性强，便于快速定位缺陷。</p></li><li><p>在函数级别开始测试工作，缺陷修复的成本低。</p></li><li><p>有助于了解测试的覆盖程度。</p></li><li><p>有助于代码优化和缺陷预防。</p></li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li><p>对测试人员要求高</p><ul><li>测试人员需要具备一定的编程经验白盒测试工程师需要具备广博的知识面</li></ul></li><li><p>成本高</p><ul><li>白盒测试准备时间较长</li></ul></li></ul><h2 id="白盒测试的经济学问题"><a href="#白盒测试的经济学问题" class="headerlink" title="白盒测试的经济学问题"></a>白盒测试的经济学问题</h2><ul><li><p>软件测试是不完备的</p></li><li><p>软件测试是有风险的</p></li><li><p>测试设计应达到的目标</p></li></ul><h2 id="逻辑覆盖"><a href="#逻辑覆盖" class="headerlink" title="逻辑覆盖"></a>逻辑覆盖</h2><h3 id="1-语句覆盖"><a href="#1-语句覆盖" class="headerlink" title="1.语句覆盖"></a>1.语句覆盖</h3><p><strong>定义</strong>：设计测试用例时，<strong>需要保证程序中每一条可执行语句至少应执行一次</strong>。（也就是点覆盖）.</p><p><strong>缺点</strong>：语句覆盖是最弱的一种覆盖标准，它主要存在两方面弊端。</p><ul><li>关注语句，而非关注判定节点。</li><li>对隐式分支无效。</li></ul><p>实例：</p><p>测试用例的执行路径覆盖了全部的节点。</p><p><img src="/2020/06/16/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/1592288092104.png" alt="语句覆盖"></p><h3 id="2-判定覆盖"><a href="#2-判定覆盖" class="headerlink" title="2.判定覆盖"></a>2.判定覆盖</h3><p><strong>定义</strong>：判定覆盖也称为分支覆盖;设计测试用例时，<strong>应保证程序中每个判定节点取得每种可能的结果至少一次</strong>。判定覆盖相当于对控制流图进行边覆盖。</p><p><strong>缺点</strong>：当判定节点中包含的是复合判定表达式时，即由多个简单判定条件通过“与”、“或关系连接而成的判定。此时，判定覆盖仅关心表达式的整体取值,并不关心表达式如何构成，不能覆盖到每个子条件的所有取值情况，由此导致测试的漏洞。</p><p>实例：</p><p>设计的测试用例将两个判定节点取真和取假都执行了一次。</p><p><img src="/2020/06/16/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/1592288200690.png" alt="判定覆盖"></p><h3 id="3-条件覆盖"><a href="#3-条件覆盖" class="headerlink" title="3.条件覆盖"></a>3.条件覆盖</h3><p><strong>定义</strong>：设计测试用例时，应保证程序中每个复合判定表达式中，每<strong>个简单判定条件的取真和取假情况至少执行一次</strong>。.</p><p>条件覆盖并不能确保满足判定覆盖，相比判定覆盖，条件覆盖虽然进一步深入检查了判定节点中的每个子条件，但判定节点局部的完全覆盖并不能保证对判定节点整体的完全覆盖。</p><p>实例：</p><p>每一个简单的判定条件的取真和取假的情况都执行了一次</p><p><img src="/2020/06/16/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/1592288300056.png" alt="条件覆盖"></p><h3 id="4-判定-条件覆盖"><a href="#4-判定-条件覆盖" class="headerlink" title="4.判定/条件覆盖"></a>4.判定/条件覆盖</h3><p><strong>定义</strong>：<strong>测试用例设计应满足判定节点的取真.取假分支至少执行一次，且每个简单判定条件的取真和取假情况也至少执行一次</strong>，即判定覆盖+条件覆盖。</p><h3 id="5-条件组合覆盖"><a href="#5-条件组合覆盖" class="headerlink" title="5.条件组合覆盖"></a>5.条件组合覆盖</h3><p><strong>定义</strong>：测试用例的设计应满足每个判定节点中，<strong>所有简单判定条件的所有可能的取值组合情况应至少执行一次</strong>。</p><p><strong>优势</strong>：方法简单;只需要找到所有简单条件，并列出真值表，穷尽所有组合情况即可。</p><p><strong>缺点</strong>：测试用例的冗余，而且一些条件不可能成立</p><h3 id="6-修正的判定-条件覆盖"><a href="#6-修正的判定-条件覆盖" class="headerlink" title="6.修正的判定/条件覆盖"></a>6.修正的判定/条件覆盖</h3><p><strong>基本思想</strong>:在满足判定/条件覆盖的基础上，每个简单判定条件都应独立地影响到整个判定表达式的值。<br><strong>实质</strong>:利用简单判定条件的独立影响性来消除测试用例的冗余。</p><p><strong>一般步骤：</strong></p><ul><li><p>列出所有的简单判定条件;</p></li><li><p>构建真值表;</p></li><li><p>对每个简单判定条件，找到能够对整个判定结果产生独立影响的测试用例集合(简称独立影响对) ;注意独立影响对可能不止一组。</p></li><li><p>具体措施是:抽取能体现所有简单判定条件独立影响性的最少独立影响对。</p></li></ul><p><strong>优势：</strong>综合具备条件组合覆盖的优点，有效控制了测试用例数量，消除了测试冗余。<br><strong>不足：</strong>测试用例设计较为困难。</p><p>这6种覆盖策略，基本.上是按照由弱到强的程度来设计的，但也不是绝对的。比如，满足条件覆盖时，未必满足语句覆盖或判定覆盖。</p><h3 id="7-路径覆盖（补充）"><a href="#7-路径覆盖（补充）" class="headerlink" title="7.路径覆盖（补充）"></a>7.路径覆盖（补充）</h3><p><strong>定义：</strong>就是将程序中所有可能的路径都覆盖一次</p><h2 id="基本路径法"><a href="#基本路径法" class="headerlink" title="基本路径法"></a>基本路径法</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>基本路径测试方法是白盒测试最为典型的测试方法。</p><p>基本路径测试方法:在程序控制流图的基础上通过分析程序的圈复杂度，导出独立路径集合，从而设计测试用例的方法。</p><h3 id="2-控制流图"><a href="#2-控制流图" class="headerlink" title="2.控制流图"></a>2.控制流图</h3><p><img src="/2020/06/16/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/1592357916987.png" alt="控制流图"></p><p>在分支的汇聚的地方应该有也是一个节点</p><p>如果一个判定节点里面有多个简单的判定条件，如要改成单条件的嵌套判断</p><p>节点的序号最好使用代码的行号进行表达。</p><p><img src="/2020/06/16/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/1592358468630.png" alt="控制流图和代码"></p><h3 id="3-计算复杂度"><a href="#3-计算复杂度" class="headerlink" title="3.计算复杂度"></a>3.计算复杂度</h3><p><strong>定义：</strong>圈复杂度是一-种为程序逻辑复杂性提供定量测度的软件度量，将该度量用于计算程序的基本的独立路径数目，为确保所有语句至少执行一次的测试数量的上界。独立路径必须包含一条在其它独立路径中不曾用到的边。【圈复杂度==独立路径的数量】</p><p>有以下三种方法计算圈复杂度:</p><ul><li><p>流图中封闭区域的数量+1个开放区域=总的区域数=圈复杂度(注:边和结点圈定的区域叫做区域，当对区域计数时， 图形外的区域也应记为一个区域。)</p></li><li><p>给定流图G的圈复杂度V(G)，定义为V(G)= E-N+2,E是流图中边的数量，N是流图中结点的数量;</p></li><li><p>给定流图G的圈复杂度V(G)，定义为V(G)= P+1, P是流图G中判定结点的数量。</p></li></ul><h3 id="4-独立路径"><a href="#4-独立路径" class="headerlink" title="4.独立路径"></a>4.独立路径</h3><p>定义：独立路径是指，和其他的独立路径相比，至少引入一个新处理语句或一个新判断的程序通路。【就是每一个独立路径都是不相同的（从起点到终点的路径）】</p><p>圈复杂度的值正好等于该程序的独立路径的条数。</p><p>比如：</p><p>可以看出每一个路径都是不一样的。</p><p><img src="/2020/06/16/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/1592358987349.png" alt="独立路径"></p><h3 id="5-编写测试用例"><a href="#5-编写测试用例" class="headerlink" title="5.编写测试用例"></a>5.编写测试用例</h3><p>设计出的测试用例要保证独立路径集合中每条路径至少执行一次。[有多少个独立路径就涉及多少个测试用例]</p><p>比如：</p><p>一个测试用例包括一个独立路径</p><p><img src="/2020/06/16/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/1592359181111.png" alt="根据独立路径编写测试用例"></p><h2 id="静态白盒测试"><a href="#静态白盒测试" class="headerlink" title="静态白盒测试"></a>静态白盒测试</h2><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h3><p>软件测试不仅包括动态测试，还包括对系统的静态检查，这种检查通常不需要实际运行被测软件，而是直接对软件形式和结构进行分析。</p><h3 id="2-代码检查"><a href="#2-代码检查" class="headerlink" title="2.代码检查"></a>2.代码检查</h3><p>代码检查主要是通过同行评审来发现缺陷;以评审会议为形式，通过多人对软件交付物进行检查，从而发现缺陷，或者获得改进优化的机会;同行评审往往需要大量投入时间和人力资源。</p><p>同行评审的核心：缺陷预防</p><p>目的：发现缺陷，改进开发过程</p><p>同行评审方法【前三个比较正规，后三个比较随意】：</p><ul><li><p>审查(Inspection)</p></li><li><p>团队评审(Team Review)</p></li><li><p>走查(Walk Through)</p></li><li><p>结对编程(Pair Programming)</p></li><li><p>同行桌查(Peer Desk Check)</p></li><li><p>轮查(Pass Around)</p></li><li><p>特别检查(Ad hoc Review)</p><p>评审的过程：</p></li></ul><p><img src="/2020/06/16/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/1592359730000.png" alt="1592359730000"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>白盒测试方法综合应用策略：</strong></p><p><strong>（1）开始进行白盒测试时，首先应当尽量使用测试工具进行程序静态结构分析。</strong></p><p><strong>（2）在测试中，建议采用先静态后动态的组合方式。先进行静态结构分析和代码检查，然后再进行覆盖测试。</strong></p><p><strong>（3）利用静态分析的结果作为依据和引导，再使用代码检查和动态测试的方式对静态测试分析结果进行进一步确认，使测试工作更为准确和有效。</strong></p><p><strong>（4）覆盖率测试是白盒测试的重点，是测试报告中可以作为量化指标的依据。一般可以使用基本路径测试法达到语句覆盖的标准，对于重点模块应当使用多种覆盖率标准衡量代码的覆盖率。</strong></p><p><strong>（5）在不同的测试阶段，白盒测试的应用侧重点也不同。单元测试以代码检查和逻辑覆盖为主，集成测试需要增加静态结构分析等，而系统测试需要根据黑盒测试结果采取相应的白盒测试。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="软件测试" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>软件测试</title>
    <link href="http://yoursite.com/2020/06/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2020/06/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/</id>
    <published>2020-06-14T06:27:41.000Z</published>
    <updated>2020-06-16T06:41:49.935Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="软件测试——基本知识"><a href="#软件测试——基本知识" class="headerlink" title="软件测试——基本知识"></a>软件测试——基本知识</h1><h2 id="软件测试的定义"><a href="#软件测试的定义" class="headerlink" title="软件测试的定义"></a>软件测试的定义</h2><p>​        <strong>软件测试是人工的或通过使用工具来自动的运行被测软件系统，或静态检查被测系统的过程，其目的在于校验被测系统是否满足需求，或要弄清楚实际的 系统输出与预期系统输出的差异。</strong></p><p><img src="/2020/06/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/ruanjianceshidingyi.png" alt="软件测试"></p><p>​        从中可以看出<strong>软件测试的目的是确保被测系统满足用户需求。</strong></p><ul><li><p>软件测试以需求为中心。</p></li><li><p>软件测试包括动态测试和静态检查两类方法</p></li><li><p>测试的执行包括人工和自动化两类策略</p><p>动态（手工）测试：</p><ul><li>提供被测对象</li><li>准备相关的预期（文档）</li><li>设计测试用例</li><li>搭建测试环境</li><li>运行测试用例</li><li>检查测试结果</li><li>记录测试的过程</li><li>报告缺陷</li><li>回归测试</li><li>交付的文件：测试用例，驱动/桩模块，缺陷报告</li></ul><p>静态测试：</p><ul><li><p>提供被测对象（源代码）</p></li><li><p>准备相关的预期（文档）</p></li><li><p>阅读代码和文档</p></li><li><p>报告缺陷</p></li><li><p>回归测试</p></li></ul><p>自动化测试：</p><ul><li>提供被测对象</li><li>准备相关的预期（文档）</li><li>设计测试用例（编写测试脚本）</li><li>搭建测试环境（增加了对测试环境的配置）</li><li>运行测试用例</li><li>检查测试结果</li><li>记录测试的过程</li><li>报告缺陷</li><li>回归测试</li><li>交付的文件：测试用例，驱动/桩模块，缺陷报告，测试脚本</li></ul></li></ul><h2 id="软件测试的流程"><a href="#软件测试的流程" class="headerlink" title="软件测试的流程"></a>软件测试的流程</h2><h3 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h3><p>​        回答哪些人分别在什么时候使用哪些方法，利用哪些资源，遵循哪些标准，对系统中的哪些对象进行测试，在这个过程中可能存在哪些风险。</p><ul><li><p>输入</p><ul><li><p>需求规格说明</p></li><li><p>项目计划</p></li></ul></li><li><p>输出</p><ul><li>测试计划</li></ul></li></ul><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>​        根据用户的寻求、系统设计文档和测试计划，设计测试用例和测试过。</p><ul><li><p>输入</p><ul><li><p>需求</p></li><li><p>设计文档</p></li><li><p>测试计划</p></li></ul></li><li><p>输出</p><ul><li>测试用例</li><li>测试过程</li></ul></li></ul><h3 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h3><p>​        回答如何让测试用例跑起来，被测软件中发现了什么问题。根据测试用例设计模块，手工执行，或者根据测试用例编写测试脚本并运动，检查每一个结果，发现缺陷后提交缺陷报告。</p><ul><li><p>输入</p><ul><li><p>需求</p></li><li><p>测试用例</p></li><li><p>测试过程</p></li></ul></li><li><p>输出</p><ul><li>测试驱动模块</li><li>测试桩模块</li><li>测试脚本（可选）</li></ul></li></ul><h3 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h3><p>​    评估测试工作和被测系统，目的是回答测试工作质量怎么样，被测系统质量怎么样。</p><ul><li><p>输入</p><ul><li><p>缺陷报告</p></li><li><p>测试用例</p></li><li><p>测试标准</p></li></ul></li><li><p>输出</p><ul><li>测试评估报告</li></ul></li></ul><h2 id="软件缺陷"><a href="#软件缺陷" class="headerlink" title="软件缺陷"></a>软件缺陷</h2><h3 id="软件缺陷的定义"><a href="#软件缺陷的定义" class="headerlink" title="软件缺陷的定义:"></a>软件缺陷的定义:</h3><p><img src="/2020/06/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%BD%AF%E4%BB%B6%E7%BC%BA%E9%99%B7" alt="软件缺陷"></p><p><strong>1.软件测试人员认为软件难以理解、不易使用、运行速度缓慢，或者最终用户认为不好就是缺陷。</strong></p><p><strong>2.软件未达到需求规格说明书中指明的功能，就是缺陷</strong>。</p><ul><li>保证实现有效输入下的基本功能；</li><li>保证达到相关性能指标</li></ul><p><strong>3.软件出现了需求规格说明书中指明不会出现的错误，就是缺陷（这可视为对软件系统容错性的要求【容错性主要是依赖于测试人员的经验】）。</strong></p><ul><li>系统能否处理异常情况</li><li>系统能否识别用户输入的无效数据</li><li>系统能否处理用户无效的输入数据</li></ul><p><strong>4.软件功能超出需求规格说明书中指明的范围，就是缺陷</strong></p><ul><li>程序员错误的实现了需求规定的功能</li><li>需求规格说明有遗漏，但是程序员完成了</li><li>人为加入的一些超出需求规格说明书的功能（意外或者病毒）</li></ul><p><strong>5.软件未达到需求规格说明书中虽然没有指出，但是应该达到的目标，就是缺陷</strong></p><ul><li>软件的一些隐含的特性（一些对于异常的处理，或者与用户相关专业有关）</li></ul><h2 id="软件质量"><a href="#软件质量" class="headerlink" title="软件质量"></a>软件质量</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><img src="/2020/06/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/1592202129652.png" alt="软件质量"></p><p>质量：反映实体满足明确或隐含需要能力的特性总和</p><p>质量的三要素：</p><ul><li><p>实体</p><ul><li>实体是质量的主体，即测量的主体。-般指产品，也可以是活动、过程、组织、人，或者它们的组合。</li></ul></li><li><p>特性集合</p><ul><li>表示度量，特性必须可以测量，定性或定量方式得到指导性结论。</li></ul></li><li><p>需求</p></li></ul><p><strong>软件质量：反应软件满足明确或隐含能力的特性总和。</strong></p><p>​    客观而言，软件质量是软件具有某种能力的属性，这是前提条件<br>​    主观而言，软件具有的能力对应不同层次的用户需求</p><ul><li>侠义的软件质量：软件的内部质量，即软件无故障。</li><li>广义的软件质量：产品质量、过程质量和客户满意度。</li></ul><p><strong>软件测试不能提高软件质量，提高软件质量必须依靠改进软件开发过程的质量。</strong></p><p>软件质量的特性：</p><ul><li>功能性、可靠性、易用性、效率、可移植、可维护 </li></ul><h2 id="软件测试的分类"><a href="#软件测试的分类" class="headerlink" title="软件测试的分类"></a>软件测试的分类</h2><p>1、<strong>按照测试目标分类</strong>:可以分为功能测试、性能测试、可靠性测试、安全性测试、易用性测试等。</p><ul><li><p>功能测试: 针对软件功能需求进行测试，目的是检查应用程序的行为是否符合预期。</p></li><li><p>性能测试: 用于验证系统是否满足规格说明的性能需求，例如容量和响应时间等。</p><p>……</p></li></ul><p>2、<strong>按照执行方式分类</strong>:可以分为静态测试与动态测试。</p><ul><li>静态测试:不执行被测对象，通过检查、阅读进行分析。</li><li>动态测试:运行被测对象，通过观察运行过程进行验证。</li></ul><p>3、<strong>按照测试方法分类</strong>:可以分为白盒测试、黑盒测试、灰盒测试。</p><ul><li>黑盒测试关注的是与产 品的外部行为相关的缺陷，此时并不考虑产品的内部结构或运行逻辑。</li><li>白盒测试关注的是 与代码内部结构相关的缺陷，因此，需要测试人员掌握一定的编程技术。</li><li>灰盒测试是综合运用黑 盒测试和白盒测试技术的一种混合测试方法。</li></ul><p>4、<strong>按照测试阶段分类</strong>:可以分为单元测试、集成测试、系统测试、验收测试四个测试阶段。（V模型）</p><ul><li>单元测试用于验证一个单元模块(或组件)的功能是否正常，一个单元模块可以包括几行或上百行代码。（主要采用白盒测试）</li><li>集成测试是将不同的单元模块组合在一起，形成更大组件的测试过程。</li><li>系统测试用于检验软件产品是否能与系统的其它部分协调工作，包括硬件、数据库及操作人员等。</li><li>验收测试是软件部署之前的一个测试操作，其测试范围类似于系统测试，通常是由系统提供者和客户来共同完成。以确定系统是否满足验收标准</li></ul><h2 id="软件测试过程模型"><a href="#软件测试过程模型" class="headerlink" title="软件测试过程模型"></a>软件测试过程模型</h2><h3 id="V模型"><a href="#V模型" class="headerlink" title="V模型"></a>V模型</h3><p>V模型是最早提出来的测试模型，旨在改进软件的效率和效果。</p><p><img src="/2020/06/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/1592203424906.png" alt="V模型"></p><p>V模型的局限性：没有明确说明早期检测的重要性，不能提现“尽早开展测试的原则”</p><h3 id="W模型"><a href="#W模型" class="headerlink" title="W模型"></a>W模型</h3><p><img src="/2020/06/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/1592203570161.png" alt="W模型"></p><p><strong>W模型的价值和意义</strong>：</p><ul><li>注重在软件开发的各个阶段应用静态测试技术，使得在执行开发过程的同时执行测试,实现了真<br>正的开发与测试并行。</li><li>强调尽早展开测试，能够在开发早期发现缺陷,降低缺陷修改成本。</li></ul><p><strong>W模型的局限性:</strong></p><ul><li>将软件开发阶段视为串行活动,无法有效支持迭代及变更调整。</li></ul><h3 id="H模型"><a href="#H模型" class="headerlink" title="H模型"></a>H模型</h3><p><img src="/2020/06/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/1592203751602.png" alt="H模型"></p><h3 id="模型总结："><a href="#模型总结：" class="headerlink" title="模型总结："></a>模型总结：</h3><p>V模型的含义：强调了测试阶段划分,测试阶段与开发阶段的对应性<br>W模型的含义：强调了早期测试、静态测试的重要性<br>H模型的含义：强调了测试活动是独立的,与其他流程并发进行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="软件测试" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/06/04/hello-world/"/>
    <id>http://yoursite.com/2020/06/04/hello-world/</id>
    <published>2020-06-04T07:13:57.580Z</published>
    <updated>2020-06-04T07:13:57.580Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
