<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>皮之鲲</title>
  
  <subtitle>总不能还没努力就向生活妥协</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-19T09:07:12.270Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>皮皮鲲</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>黑盒测试</title>
    <link href="http://yoursite.com/2020/06/18/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2020/06/18/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/</id>
    <published>2020-06-18T08:58:08.000Z</published>
    <updated>2020-06-19T09:07:12.270Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>定义</strong>：只知道系统输入和预期输出，不需要了解程序内部结构和内部特性的测试方法就称为黑盒测试。</p><p><strong>黑盒测试的优势</strong>：</p><ul><li><p>方法简单有效</p></li><li><p>可以整体测试系统的行为</p></li><li><p>开发与测试可以并行</p></li><li><p>对测试人员技术要求相对较低</p></li></ul><p><strong>黑盒测试的经济学问题</strong>：</p><ul><li>通过测试无法证明，被测软件系统是没有缺陷的。</li></ul><p><strong>黑盒测试的评价标准</strong>：</p><p>在最短时间内，以最少的人力，有利于发现最多的，以及最严重的缺陷。</p><ul><li><p>精确的:测试针对性强（设计测试用例的数量越少越好）</p></li><li><p>完备的:测试覆盖全面，无漏洞</p></li><li><p>无冗余</p></li><li><p>简单的:测试方法简单易行</p></li><li><p>易于调试:缺陷定位难度小</p></li></ul><h2 id="等价类测试"><a href="#等价类测试" class="headerlink" title="等价类测试"></a>等价类测试</h2><p><strong>基本原理：</strong></p><p>输入的数据不同，但是的到的结果是相同的，也就是输入x,y则F(x) = F(y)，这就是一个等价类</p><p><strong>等价类的划分</strong></p><p>输入测试:划分有效等价类、效等价类.</p><p>输出测试:有效等价类(通常只针对有效等价类进行设计)</p><ul><li><p>有效等价类</p><ul><li>有效等价类对应有效输入域的数据</li><li>有效等价类设计的测试用例用于检验被测系统是否能够正确完成指定功能</li></ul></li><li><p>无效等价类</p><ul><li>无效等价类则对应无效输入域中的数据</li><li>无效等价类设计的测试用例被用来考察.被测系统的容错性</li></ul></li></ul><p><strong>等价类的测试流程</strong>：</p><ul><li><p>确定有几类输出结果</p></li><li><p>对每类输出结果划分等价类.</p></li><li><p>划分等价后,建立等价类表,妫每个等价类规定-一个唯一 的编号;</p></li><li><p>设计一个测试用例，使其尽可能多地覆盖尚未被覆盖地有效等价类,蝮这-步骤, 直到所有的有效等价类都被覆盖为止;</p></li><li><p>设计-个新的测试用例，使其仅覆盖-个尚未被覆盖的无效等价类, 蝮这-步骤,直到所有的无效等价类都被覆盖为止。</p></li></ul><h2 id="边界值测试"><a href="#边界值测试" class="headerlink" title="边界值测试"></a>边界值测试</h2><p><strong>定义</strong>：</p><p>在输入输出变量范围的边界上，验证系统功能是否正常运行的测试方法。</p><p><strong>输出域的测试用例设计流程</strong>：</p><ul><li><p>确定有几类输出结果;</p></li><li><p>确定每类输出结果的边界点;</p></li><li><p>划定边界邻域delta;</p></li><li><p>每个边界对应3个测试数据;</p></li><li><p>单边界设计测试用例。</p></li></ul><h2 id="等价类边界值案例"><a href="#等价类边界值案例" class="headerlink" title="等价类边界值案例"></a>等价类边界值案例</h2><p>题目：</p><p> 某网站注册邮箱时，邮箱名要求6~18个字符，可使用字母、数字、下划线，需以字母开头。试用等价类设计测试用例，并用边界值进行补充测试用例。要求按照写明等价类分类及编号，以及边界值的分类和编号。测试用例要求有编号、输入数据、预期结果，覆盖等价类或边界值编号等信息 </p><p>分析：</p><ul><li>先设计等价类表（确定哪些是有效等价类，哪些是无效的等价类）</li><li>设计边界值的分类表</li><li>设计测试用例（覆盖所有的等价类以及边界值）</li></ul><p>答案：</p><p><img src="/2020/06/18/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/1592526063873.png" alt="等价类边界值"></p><h2 id="决策表法"><a href="#决策表法" class="headerlink" title="决策表法"></a>决策表法</h2><p><strong>概述</strong>：</p><p>决策表(Decision Table)，又叫判定表是分析和表达多逻辑条件下执行不同操作的工具。在程序设计发展的初期，判定表被当作编写程序的辅助工具。</p><p><strong>适用场景：</strong></p><p>但是如果输入条件之间设立了一些规则，或者输入条件之间有逻辑关系，考虑决策表。</p><p><strong>具体步骤</strong>: </p><p>列出条件桩和动作桩;</p><p>确定规则个数:假如有n个条件，每个条件有两个取值，则有2”种规则;</p><p>输入条件项和动作项，得到初始决策表;</p><p>简化决策表(原则:有两条或多条规则具有相同动作，并且条件项之间存在着极为相似的关系，合并)</p><p>根据决策表设计测试用例</p><p><strong>决策表的构成</strong></p><p>条件桩:列出了问题的所有条件。</p><p>条件项:针对条件桩给出的条件列出所有可能的取值。</p><p>必动作桩:给出了问题规定的可能采取的操作。</p><p>必动作项:和条件项紧密相关，指出在条件项的各组取值情况下应采取的动作。</p><p>实例：</p><p><img src="/2020/06/18/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/1592526785902.png" alt="决策表"></p><p><strong>决策表的简化</strong>：</p><p>有两条或多条规则具有相同的动作，并且其条件项之间存在着极为相似的关系，就可以将规则合并。</p><p>例如：上图中的1和2,他的动作都是A4，并且他的条件C1和C2都为T，无论C3是T还是F都不影响动作，因此可以将其进行合并.</p><p>实例：</p><p><img src="/2020/06/18/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/1592527005349.png" alt="化简"></p><p>根据这一个化简的方法，可以得出下面这个已经化简的决策表：</p><p><img src="/2020/06/18/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/1592527113205.png" alt="化简之后的决策表"></p><h2 id="因果图法"><a href="#因果图法" class="headerlink" title="因果图法"></a>因果图法</h2><p>4中符号：</p><p>因果图中使用了简单的逻辑符号，以直线连接左右节点。左节点表示输入状态(或称原因)，右节点表示输出状态(或称结果)。</p><ul><li>恒等：原因为1，则结果也为1</li><li>非：原因为1，则结果为0</li><li>或：原因都为1,则结果为1；否则结果为0</li><li>与：原因有一个为1，结果为1；如果都为0，则为0</li></ul><p><img src="/2020/06/18/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/1592527851214.png" alt="恒等和非"></p><p><img src="/2020/06/18/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/1592528376368.png" alt="或 与"></p><p><strong>输入条件约束</strong></p><p>E约束（互斥）：原因a和原因b不会同时成.工，两个中最多有一个可能成立。</p><p><img src="/2020/06/18/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/1592529453599.png" alt="E约束"></p><p>I约束（包含）：a、b、c这三个原因中至少有一个必须成立。</p><p><img src="/2020/06/18/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/1592529530445.png" alt="I约束"></p><p>o约束（唯一） ：原因a和b中必须有一个，且仅有一个成立。</p><p><img src="/2020/06/18/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/1592529922992.png" alt="o约束"></p><p>R约束（要求）:原因a出现时，原因b也必须出现，a出现时，不可能b不出现。</p><p><img src="/2020/06/18/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/1592530015381.png" alt="R约束"></p><p><strong>输出条件的约束</strong></p><p>M约束（屏蔽或强制）：结果a为1，则结果b值为0。当a为0,b的值不确定。</p><p><img src="/2020/06/18/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/1592530132128.png" alt="M约束"></p><p>因果图设计测试用例：</p><ul><li>根据题目判断出原因和结果</li><li>根据原因和结果写出因果图</li><li>根据因果图写出决策表</li><li>根据决策表设计测试用例</li></ul><h2 id="正交表"><a href="#正交表" class="headerlink" title="正交表"></a>正交表</h2><p> 正交表是一种特制的表格，一般用Ln(mk)表示，L代表是正交表，n代表试验次数或正交表的行数（测试用例的个数），k代表最多可安排影响指标因素的个数或正交表的列数，m表示每个因素水平数，且有n=k*(m-1)+1。</p><p>（1）因素（Factors）。表示在一项试验中，需要观察的变量称为因素。</p><p>（2）水平位（（Levels）。表示在试验范围内，因素被考察的值称为水平位（变量的取值）</p><p>（3）正交表的组成。由行数（正交表的行的个数，即试验的次数）、因素数（正交表列的个数）、水平数（任何单个因素能够取得的值得最大个数）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="软件测试" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Spring5</title>
    <link href="http://yoursite.com/2020/06/17/Spring5/"/>
    <id>http://yoursite.com/2020/06/17/Spring5/</id>
    <published>2020-06-17T02:37:10.000Z</published>
    <updated>2020-06-19T09:06:53.609Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Spring5"><a href="#Spring5" class="headerlink" title="Spring5"></a>Spring5</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>（1）Spring是一个轻量级的开源的JavaEE的框架</p><p>（2）Spring可以解决企业开发应用的复杂性</p><p>（3）Spring有两个核心部分：IOC和AOP</p><ul><li>IOC:控制反转：把创建对象的过程交给Spring进行管理</li><li>AOP:面向切面编程，不修改源代码进行功能的增强</li></ul><p>（4）Spring的特点：</p><ul><li>方便解耦，简化开发</li><li>方便程序的测试</li><li>Aop的支持</li><li>方便整合其他的框架</li><li>方便进行事务的操作</li><li>降低了API的开发难度</li></ul><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>（1）下载Jar包</p><ul><li><p>先到官网下载jar包   <a href="https://repo.spring.io/release/org/springframework/spring/" target="_blank" rel="noopener">https://repo.spring.io/release/org/springframework/spring/</a> </p></li><li><p>选取最新的点击下载就可以了</p></li></ul><p>（2）创建工程，选取jar包</p><p>下面是Spring的基础包：</p><p><img src="/2020/06/17/Spring5/1592362693529.png" alt="jar包"></p><p>另外还需要一个日志包进行对日志的相关记录：</p><ul><li>commons-logging-1.2.jar</li></ul><p>将上面的jar包进行导入</p><p>（3）创建一个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"这个是user类"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4)创建配置类</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置User对象的创建--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.bean.User"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(5)创建测试类进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//加载配置文件</span></span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean1.xml"</span>);</span><br><span class="line">    <span class="comment">//获取配置中创建的对象</span></span><br><span class="line">    User user = context.getBean(<span class="string">"user"</span>, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    user.add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h2><h3 id="IOC的概念和原理"><a href="#IOC的概念和原理" class="headerlink" title="IOC的概念和原理"></a>IOC的概念和原理</h3><p>（1）概念：控制反转，把对象的创建和对象之间的调用过程，交给spring进行管理。</p><p>（2）使用IOC的目的：为了耦合度的降低</p><p>（3）IOC的底层原理：</p><ul><li>XML解析</li><li>工厂模式<ul><li>就是利用一个工厂类来解耦两个类</li><li>实例：当UserService想要创建UserDao类的时候，不需要直接new，通过UserFactory类来获取UserDao</li><li><img src="/2020/06/17/Spring5/1592401410337.png" alt="1592401410337"></li></ul></li><li>反射</li></ul><p>（4）IOC的实现过程</p><ul><li>先在XML配置相关的文件，配置创建的对象</li><li>根据配置文件创建工厂类（通过反射）<ul><li>先解析xml文件获取类的名称</li><li>通过反射获取该类的Class文件</li><li>通过newInstance方法获取该类并进行强制转换</li><li>最后将该类返回</li></ul></li></ul><p><img src="/2020/06/17/Spring5/1592550369004.png" alt="IOC的实现过程"></p><p>(5)IOC思想基于IOC容器完成，IOC容器底层就是对象工厂</p><p>(6)Spring提供IOC容器实现两种方式：（两个接口）</p><ul><li>BeanFactory：IOC容器基本实现（Spring内部使用的接口，一般不提供给开发人员使用）<ul><li>加载配置文件的时候不会创建配置文件中的对象，在获取对象才会创建对象</li></ul></li><li>ApplicationContext：BeanFactory接口的子接口，提供更多强大的功能，一般由开发人员进行使用<ul><li>加载配置文件的时候就会把配置文件中的对象进行创建</li></ul></li></ul><p>一般会使用ApplicationContext</p><p>（7）ApplicationContext中的一些实现类</p><p><img src="/2020/06/17/Spring5/1592552079903.png" alt="ApplicationContext的实现类"></p><p>FileSystemXmlApplicationContext：对应配置文件（XML）的磁盘中的位置</p><p>ClassPathXmlApplicationContext：对应src下面配置文件的位置</p><h3 id="IOC操作Bean管理"><a href="#IOC操作Bean管理" class="headerlink" title="IOC操作Bean管理"></a>IOC操作Bean管理</h3><h4 id="Bean管理概述"><a href="#Bean管理概述" class="headerlink" title="Bean管理概述"></a>Bean管理概述</h4><p>Bean管理指的是两个操作：</p><p>（1）Spring创建对象:由Spring代替我们创建对象，我们只需要在xml进行配制</p><p>（2）Spring注入属性:Spring可以向配置的类中注入相关的属性的值</p><p>Bean管理的 实现方式：</p><p>（1）基于Xml配置文件方式实现</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置User对象的创建--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.bean.User"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>id：获取对象的标识（唯一）</li><li>class：全类名，指定需要配置的类</li><li>name：和id的作用是一样的，区别：name里面可以添加一些特殊的符号（/等）一般不用</li></ul><p>在创建对象的时候默认是<strong>使用无参数的构造器</strong></p><p>（2）基于注解方式实现</p><p>DI:依赖注入（注入属性）这是IOC的一种具体实现，表示依赖注入，这个需要在创建对象的基础之上进行完成。（先创建对象后注入属性）</p><p> 第一种注入的方式：通过类本身的set方法进行注入</p><ul><li>创建一个类，并创建set 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  String bname;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBname</span><span class="params">(String bname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bname = bname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Spring的配置文件中配置对象的创建，在对属相进行注入</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    1.先创建对象</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">"book"</span> <span class="attr">class</span>=<span class="string">"com.bean.Book"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        使用property完成属性的注入</span></span><br><span class="line"><span class="comment">            name:类里面的属性名称</span></span><br><span class="line"><span class="comment">            value:向属相内赋值</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"bname"</span> <span class="attr">value</span>=<span class="string">"易经经"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二种注入的方式：通过有参构造注入</p><ul><li>先创建一个类，并创建该类中的有参构造器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  String bname;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bname = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在Spring配置文件中进行配置</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">"book1"</span> <span class="attr">class</span> = <span class="string">"com.bean.Book"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">name:属性的名称</span></span><br><span class="line"><span class="comment">value:属性的名称</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"ss"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">index:有参构造器中第i+1个参数</span></span><br><span class="line"><span class="comment">value:该参数的值</span></span><br><span class="line"><span class="comment">&lt;constructor-arg index="i" value="ss"/&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="java,Spring" scheme="http://yoursite.com/tags/java-Spring/"/>
    
  </entry>
  
  <entry>
    <title>白盒测试</title>
    <link href="http://yoursite.com/2020/06/16/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2020/06/16/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/</id>
    <published>2020-06-16T02:00:11.000Z</published>
    <updated>2020-06-19T09:07:06.083Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h1><h2 id="关注的对象"><a href="#关注的对象" class="headerlink" title="关注的对象"></a>关注的对象</h2><p>1.源代码</p><ul><li>措施:阅读源代码，检验代码的规范性,并对照函数功能查找代码的逻辑缺陷、内存管理缺陷、数据定义和使用缺陷等</li></ul><p>2.程序结构</p><ul><li>措施:使用与程序设计相关的图表，找到程序设计的缺陷，或评价程序的执行效率</li></ul><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul><li><p>针对性强，便于快速定位缺陷。</p></li><li><p>在函数级别开始测试工作，缺陷修复的成本低。</p></li><li><p>有助于了解测试的覆盖程度。</p></li><li><p>有助于代码优化和缺陷预防。</p></li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li><p>对测试人员要求高</p><ul><li>测试人员需要具备一定的编程经验白盒测试工程师需要具备广博的知识面</li></ul></li><li><p>成本高</p><ul><li>白盒测试准备时间较长</li></ul></li></ul><h2 id="白盒测试的经济学问题"><a href="#白盒测试的经济学问题" class="headerlink" title="白盒测试的经济学问题"></a>白盒测试的经济学问题</h2><ul><li><p>软件测试是不完备的</p></li><li><p>软件测试是有风险的</p></li><li><p>测试设计应达到的目标</p></li></ul><h2 id="逻辑覆盖"><a href="#逻辑覆盖" class="headerlink" title="逻辑覆盖"></a>逻辑覆盖</h2><h3 id="1-语句覆盖"><a href="#1-语句覆盖" class="headerlink" title="1.语句覆盖"></a>1.语句覆盖</h3><p><strong>定义</strong>：设计测试用例时，<strong>需要保证程序中每一条可执行语句至少应执行一次</strong>。（也就是点覆盖）.</p><p><strong>缺点</strong>：语句覆盖是最弱的一种覆盖标准，它主要存在两方面弊端。</p><ul><li>关注语句，而非关注判定节点。</li><li>对隐式分支无效。</li></ul><p>实例：</p><p>测试用例的执行路径覆盖了全部的节点。</p><p><img src="/2020/06/16/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/1592288092104.png" alt="语句覆盖"></p><h3 id="2-判定覆盖"><a href="#2-判定覆盖" class="headerlink" title="2.判定覆盖"></a>2.判定覆盖</h3><p><strong>定义</strong>：判定覆盖也称为分支覆盖;设计测试用例时，<strong>应保证程序中每个判定节点取得每种可能的结果至少一次</strong>。判定覆盖相当于对控制流图进行边覆盖。</p><p><strong>缺点</strong>：当判定节点中包含的是复合判定表达式时，即由多个简单判定条件通过“与”、“或关系连接而成的判定。此时，判定覆盖仅关心表达式的整体取值,并不关心表达式如何构成，不能覆盖到每个子条件的所有取值情况，由此导致测试的漏洞。</p><p>实例：</p><p>设计的测试用例将两个判定节点取真和取假都执行了一次。</p><p><img src="/2020/06/16/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/1592288200690.png" alt="判定覆盖"></p><h3 id="3-条件覆盖"><a href="#3-条件覆盖" class="headerlink" title="3.条件覆盖"></a>3.条件覆盖</h3><p><strong>定义</strong>：设计测试用例时，应保证程序中每个复合判定表达式中，每<strong>个简单判定条件的取真和取假情况至少执行一次</strong>。.</p><p>条件覆盖并不能确保满足判定覆盖，相比判定覆盖，条件覆盖虽然进一步深入检查了判定节点中的每个子条件，但判定节点局部的完全覆盖并不能保证对判定节点整体的完全覆盖。</p><p>实例：</p><p>每一个简单的判定条件的取真和取假的情况都执行了一次</p><p><img src="/2020/06/16/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/1592288300056.png" alt="条件覆盖"></p><h3 id="4-判定-条件覆盖"><a href="#4-判定-条件覆盖" class="headerlink" title="4.判定/条件覆盖"></a>4.判定/条件覆盖</h3><p><strong>定义</strong>：<strong>测试用例设计应满足判定节点的取真.取假分支至少执行一次，且每个简单判定条件的取真和取假情况也至少执行一次</strong>，即判定覆盖+条件覆盖。</p><h3 id="5-条件组合覆盖"><a href="#5-条件组合覆盖" class="headerlink" title="5.条件组合覆盖"></a>5.条件组合覆盖</h3><p><strong>定义</strong>：测试用例的设计应满足每个判定节点中，<strong>所有简单判定条件的所有可能的取值组合情况应至少执行一次</strong>。</p><p><strong>优势</strong>：方法简单;只需要找到所有简单条件，并列出真值表，穷尽所有组合情况即可。</p><p><strong>缺点</strong>：测试用例的冗余，而且一些条件不可能成立</p><h3 id="6-修正的判定-条件覆盖"><a href="#6-修正的判定-条件覆盖" class="headerlink" title="6.修正的判定/条件覆盖"></a>6.修正的判定/条件覆盖</h3><p><strong>基本思想</strong>:在满足判定/条件覆盖的基础上，每个简单判定条件都应独立地影响到整个判定表达式的值。<br><strong>实质</strong>:利用简单判定条件的独立影响性来消除测试用例的冗余。</p><p><strong>一般步骤：</strong></p><ul><li><p>列出所有的简单判定条件;</p></li><li><p>构建真值表;</p></li><li><p>对每个简单判定条件，找到能够对整个判定结果产生独立影响的测试用例集合(简称独立影响对) ;注意独立影响对可能不止一组。</p></li><li><p>具体措施是:抽取能体现所有简单判定条件独立影响性的最少独立影响对。</p></li></ul><p><strong>优势：</strong>综合具备条件组合覆盖的优点，有效控制了测试用例数量，消除了测试冗余。<br><strong>不足：</strong>测试用例设计较为困难。</p><p>这6种覆盖策略，基本.上是按照由弱到强的程度来设计的，但也不是绝对的。比如，满足条件覆盖时，未必满足语句覆盖或判定覆盖。</p><h3 id="7-路径覆盖（补充）"><a href="#7-路径覆盖（补充）" class="headerlink" title="7.路径覆盖（补充）"></a>7.路径覆盖（补充）</h3><p><strong>定义：</strong>就是将程序中所有可能的路径都覆盖一次</p><h2 id="基本路径法"><a href="#基本路径法" class="headerlink" title="基本路径法"></a>基本路径法</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>基本路径测试方法是白盒测试最为典型的测试方法。</p><p>基本路径测试方法:在程序控制流图的基础上通过分析程序的圈复杂度，导出独立路径集合，从而设计测试用例的方法。</p><h3 id="2-控制流图"><a href="#2-控制流图" class="headerlink" title="2.控制流图"></a>2.控制流图</h3><p><img src="/2020/06/16/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/1592357916987.png" alt="控制流图"></p><p>在分支的汇聚的地方应该有也是一个节点</p><p>如果一个判定节点里面有多个简单的判定条件，如要改成单条件的嵌套判断</p><p>节点的序号最好使用代码的行号进行表达。</p><p><img src="/2020/06/16/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/1592358468630.png" alt="控制流图和代码"></p><h3 id="3-计算复杂度"><a href="#3-计算复杂度" class="headerlink" title="3.计算复杂度"></a>3.计算复杂度</h3><p><strong>定义：</strong>圈复杂度是一-种为程序逻辑复杂性提供定量测度的软件度量，将该度量用于计算程序的基本的独立路径数目，为确保所有语句至少执行一次的测试数量的上界。独立路径必须包含一条在其它独立路径中不曾用到的边。【圈复杂度==独立路径的数量】</p><p>有以下三种方法计算圈复杂度:</p><ul><li><p>流图中封闭区域的数量+1个开放区域=总的区域数=圈复杂度(注:边和结点圈定的区域叫做区域，当对区域计数时， 图形外的区域也应记为一个区域。)</p></li><li><p>给定流图G的圈复杂度V(G)，定义为V(G)= E-N+2,E是流图中边的数量，N是流图中结点的数量;</p></li><li><p>给定流图G的圈复杂度V(G)，定义为V(G)= P+1, P是流图G中判定结点的数量。</p></li></ul><h3 id="4-独立路径"><a href="#4-独立路径" class="headerlink" title="4.独立路径"></a>4.独立路径</h3><p>定义：独立路径是指，和其他的独立路径相比，至少引入一个新处理语句或一个新判断的程序通路。【就是每一个独立路径都是不相同的（从起点到终点的路径）】</p><p>圈复杂度的值正好等于该程序的独立路径的条数。</p><p>比如：</p><p>可以看出每一个路径都是不一样的。</p><p><img src="/2020/06/16/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/1592358987349.png" alt="独立路径"></p><h3 id="5-编写测试用例"><a href="#5-编写测试用例" class="headerlink" title="5.编写测试用例"></a>5.编写测试用例</h3><p>设计出的测试用例要保证独立路径集合中每条路径至少执行一次。[有多少个独立路径就涉及多少个测试用例]</p><p>比如：</p><p>一个测试用例包括一个独立路径</p><p><img src="/2020/06/16/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/1592359181111.png" alt="根据独立路径编写测试用例"></p><h2 id="静态白盒测试"><a href="#静态白盒测试" class="headerlink" title="静态白盒测试"></a>静态白盒测试</h2><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h3><p>软件测试不仅包括动态测试，还包括对系统的静态检查，这种检查通常不需要实际运行被测软件，而是直接对软件形式和结构进行分析。</p><h3 id="2-代码检查"><a href="#2-代码检查" class="headerlink" title="2.代码检查"></a>2.代码检查</h3><p>代码检查主要是通过同行评审来发现缺陷;以评审会议为形式，通过多人对软件交付物进行检查，从而发现缺陷，或者获得改进优化的机会;同行评审往往需要大量投入时间和人力资源。</p><p>同行评审的核心：缺陷预防</p><p>目的：发现缺陷，改进开发过程</p><p>同行评审方法【前三个比较正规，后三个比较随意】：</p><ul><li><p>审查(Inspection)</p></li><li><p>团队评审(Team Review)</p></li><li><p>走查(Walk Through)</p></li><li><p>结对编程(Pair Programming)</p></li><li><p>同行桌查(Peer Desk Check)</p></li><li><p>轮查(Pass Around)</p></li><li><p>特别检查(Ad hoc Review)</p><p>评审的过程：</p></li></ul><p><img src="/2020/06/16/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/1592359730000.png" alt="1592359730000"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>白盒测试方法综合应用策略：</strong></p><p><strong>（1）开始进行白盒测试时，首先应当尽量使用测试工具进行程序静态结构分析。</strong></p><p><strong>（2）在测试中，建议采用先静态后动态的组合方式。先进行静态结构分析和代码检查，然后再进行覆盖测试。</strong></p><p><strong>（3）利用静态分析的结果作为依据和引导，再使用代码检查和动态测试的方式对静态测试分析结果进行进一步确认，使测试工作更为准确和有效。</strong></p><p><strong>（4）覆盖率测试是白盒测试的重点，是测试报告中可以作为量化指标的依据。一般可以使用基本路径测试法达到语句覆盖的标准，对于重点模块应当使用多种覆盖率标准衡量代码的覆盖率。</strong></p><p><strong>（5）在不同的测试阶段，白盒测试的应用侧重点也不同。单元测试以代码检查和逻辑覆盖为主，集成测试需要增加静态结构分析等，而系统测试需要根据黑盒测试结果采取相应的白盒测试。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="软件测试" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>软件测试</title>
    <link href="http://yoursite.com/2020/06/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2020/06/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/</id>
    <published>2020-06-14T06:27:41.000Z</published>
    <updated>2020-06-19T09:07:18.778Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="软件测试——基本知识"><a href="#软件测试——基本知识" class="headerlink" title="软件测试——基本知识"></a>软件测试——基本知识</h1><h2 id="软件测试的定义"><a href="#软件测试的定义" class="headerlink" title="软件测试的定义"></a>软件测试的定义</h2><p>​        <strong>软件测试是人工的或通过使用工具来自动的运行被测软件系统，或静态检查被测系统的过程，其目的在于校验被测系统是否满足需求，或要弄清楚实际的 系统输出与预期系统输出的差异。</strong></p><p><img src="/2020/06/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/ruanjianceshidingyi.png" alt="软件测试"></p><p>​        从中可以看出<strong>软件测试的目的是确保被测系统满足用户需求。</strong></p><ul><li><p>软件测试以需求为中心。</p></li><li><p>软件测试包括动态测试和静态检查两类方法</p></li><li><p>测试的执行包括人工和自动化两类策略</p><p>动态（手工）测试：</p><ul><li>提供被测对象</li><li>准备相关的预期（文档）</li><li>设计测试用例</li><li>搭建测试环境</li><li>运行测试用例</li><li>检查测试结果</li><li>记录测试的过程</li><li>报告缺陷</li><li>回归测试</li><li>交付的文件：测试用例，驱动/桩模块，缺陷报告</li></ul><p>静态测试：</p><ul><li><p>提供被测对象（源代码）</p></li><li><p>准备相关的预期（文档）</p></li><li><p>阅读代码和文档</p></li><li><p>报告缺陷</p></li><li><p>回归测试</p></li></ul><p>自动化测试：</p><ul><li>提供被测对象</li><li>准备相关的预期（文档）</li><li>设计测试用例（编写测试脚本）</li><li>搭建测试环境（增加了对测试环境的配置）</li><li>运行测试用例</li><li>检查测试结果</li><li>记录测试的过程</li><li>报告缺陷</li><li>回归测试</li><li>交付的文件：测试用例，驱动/桩模块，缺陷报告，测试脚本</li></ul></li></ul><h2 id="软件测试的流程"><a href="#软件测试的流程" class="headerlink" title="软件测试的流程"></a>软件测试的流程</h2><h3 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h3><p>​        回答哪些人分别在什么时候使用哪些方法，利用哪些资源，遵循哪些标准，对系统中的哪些对象进行测试，在这个过程中可能存在哪些风险。</p><ul><li><p>输入</p><ul><li><p>需求规格说明</p></li><li><p>项目计划</p></li></ul></li><li><p>输出</p><ul><li>测试计划</li></ul></li></ul><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>​        根据用户的寻求、系统设计文档和测试计划，设计测试用例和测试过。</p><ul><li><p>输入</p><ul><li><p>需求</p></li><li><p>设计文档</p></li><li><p>测试计划</p></li></ul></li><li><p>输出</p><ul><li>测试用例</li><li>测试过程</li></ul></li></ul><h3 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h3><p>​        回答如何让测试用例跑起来，被测软件中发现了什么问题。根据测试用例设计模块，手工执行，或者根据测试用例编写测试脚本并运动，检查每一个结果，发现缺陷后提交缺陷报告。</p><ul><li><p>输入</p><ul><li><p>需求</p></li><li><p>测试用例</p></li><li><p>测试过程</p></li></ul></li><li><p>输出</p><ul><li>测试驱动模块</li><li>测试桩模块</li><li>测试脚本（可选）</li></ul></li></ul><h3 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h3><p>​    评估测试工作和被测系统，目的是回答测试工作质量怎么样，被测系统质量怎么样。</p><ul><li><p>输入</p><ul><li><p>缺陷报告</p></li><li><p>测试用例</p></li><li><p>测试标准</p></li></ul></li><li><p>输出</p><ul><li>测试评估报告</li></ul></li></ul><h2 id="软件缺陷"><a href="#软件缺陷" class="headerlink" title="软件缺陷"></a>软件缺陷</h2><h3 id="软件缺陷的定义"><a href="#软件缺陷的定义" class="headerlink" title="软件缺陷的定义:"></a>软件缺陷的定义:</h3><p><img src="/2020/06/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%BD%AF%E4%BB%B6%E7%BC%BA%E9%99%B7" alt="软件缺陷"></p><p><strong>1.软件测试人员认为软件难以理解、不易使用、运行速度缓慢，或者最终用户认为不好就是缺陷。</strong></p><p><strong>2.软件未达到需求规格说明书中指明的功能，就是缺陷</strong>。</p><ul><li>保证实现有效输入下的基本功能；</li><li>保证达到相关性能指标</li></ul><p><strong>3.软件出现了需求规格说明书中指明不会出现的错误，就是缺陷（这可视为对软件系统容错性的要求【容错性主要是依赖于测试人员的经验】）。</strong></p><ul><li>系统能否处理异常情况</li><li>系统能否识别用户输入的无效数据</li><li>系统能否处理用户无效的输入数据</li></ul><p><strong>4.软件功能超出需求规格说明书中指明的范围，就是缺陷</strong></p><ul><li>程序员错误的实现了需求规定的功能</li><li>需求规格说明有遗漏，但是程序员完成了</li><li>人为加入的一些超出需求规格说明书的功能（意外或者病毒）</li></ul><p><strong>5.软件未达到需求规格说明书中虽然没有指出，但是应该达到的目标，就是缺陷</strong></p><ul><li>软件的一些隐含的特性（一些对于异常的处理，或者与用户相关专业有关）</li></ul><h2 id="软件质量"><a href="#软件质量" class="headerlink" title="软件质量"></a>软件质量</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><img src="/2020/06/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/1592202129652.png" alt="软件质量"></p><p>质量：反映实体满足明确或隐含需要能力的特性总和</p><p>质量的三要素：</p><ul><li><p>实体</p><ul><li>实体是质量的主体，即测量的主体。-般指产品，也可以是活动、过程、组织、人，或者它们的组合。</li></ul></li><li><p>特性集合</p><ul><li>表示度量，特性必须可以测量，定性或定量方式得到指导性结论。</li></ul></li><li><p>需求</p></li></ul><p><strong>软件质量：反应软件满足明确或隐含能力的特性总和。</strong></p><p>​    客观而言，软件质量是软件具有某种能力的属性，这是前提条件<br>​    主观而言，软件具有的能力对应不同层次的用户需求</p><ul><li>侠义的软件质量：软件的内部质量，即软件无故障。</li><li>广义的软件质量：产品质量、过程质量和客户满意度。</li></ul><p><strong>软件测试不能提高软件质量，提高软件质量必须依靠改进软件开发过程的质量。</strong></p><p>软件质量的特性：</p><ul><li>功能性、可靠性、易用性、效率、可移植、可维护 </li></ul><h2 id="软件测试的分类"><a href="#软件测试的分类" class="headerlink" title="软件测试的分类"></a>软件测试的分类</h2><p>1、<strong>按照测试目标分类</strong>:可以分为功能测试、性能测试、可靠性测试、安全性测试、易用性测试等。</p><ul><li><p>功能测试: 针对软件功能需求进行测试，目的是检查应用程序的行为是否符合预期。</p></li><li><p>性能测试: 用于验证系统是否满足规格说明的性能需求，例如容量和响应时间等。</p><p>……</p></li></ul><p>2、<strong>按照执行方式分类</strong>:可以分为静态测试与动态测试。</p><ul><li>静态测试:不执行被测对象，通过检查、阅读进行分析。</li><li>动态测试:运行被测对象，通过观察运行过程进行验证。</li></ul><p>3、<strong>按照测试方法分类</strong>:可以分为白盒测试、黑盒测试、灰盒测试。</p><ul><li>黑盒测试关注的是与产 品的外部行为相关的缺陷，此时并不考虑产品的内部结构或运行逻辑。</li><li>白盒测试关注的是 与代码内部结构相关的缺陷，因此，需要测试人员掌握一定的编程技术。</li><li>灰盒测试是综合运用黑 盒测试和白盒测试技术的一种混合测试方法。</li></ul><p>4、<strong>按照测试阶段分类</strong>:可以分为单元测试、集成测试、系统测试、验收测试四个测试阶段。（V模型）</p><ul><li>单元测试用于验证一个单元模块(或组件)的功能是否正常，一个单元模块可以包括几行或上百行代码。（主要采用白盒测试）</li><li>集成测试是将不同的单元模块组合在一起，形成更大组件的测试过程。</li><li>系统测试用于检验软件产品是否能与系统的其它部分协调工作，包括硬件、数据库及操作人员等。</li><li>验收测试是软件部署之前的一个测试操作，其测试范围类似于系统测试，通常是由系统提供者和客户来共同完成。以确定系统是否满足验收标准</li></ul><h2 id="软件测试过程模型"><a href="#软件测试过程模型" class="headerlink" title="软件测试过程模型"></a>软件测试过程模型</h2><h3 id="V模型"><a href="#V模型" class="headerlink" title="V模型"></a>V模型</h3><p>V模型是最早提出来的测试模型，旨在改进软件的效率和效果。</p><p><img src="/2020/06/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/1592203424906.png" alt="V模型"></p><p>V模型的局限性：没有明确说明早期检测的重要性，不能提现“尽早开展测试的原则”</p><h3 id="W模型"><a href="#W模型" class="headerlink" title="W模型"></a>W模型</h3><p><img src="/2020/06/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/1592203570161.png" alt="W模型"></p><p><strong>W模型的价值和意义</strong>：</p><ul><li>注重在软件开发的各个阶段应用静态测试技术，使得在执行开发过程的同时执行测试,实现了真<br>正的开发与测试并行。</li><li>强调尽早展开测试，能够在开发早期发现缺陷,降低缺陷修改成本。</li></ul><p><strong>W模型的局限性:</strong></p><ul><li>将软件开发阶段视为串行活动,无法有效支持迭代及变更调整。</li></ul><h3 id="H模型"><a href="#H模型" class="headerlink" title="H模型"></a>H模型</h3><p><img src="/2020/06/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/1592203751602.png" alt="H模型"></p><h3 id="模型总结："><a href="#模型总结：" class="headerlink" title="模型总结："></a>模型总结：</h3><p>V模型的含义：强调了测试阶段划分,测试阶段与开发阶段的对应性<br>W模型的含义：强调了早期测试、静态测试的重要性<br>H模型的含义：强调了测试活动是独立的,与其他流程并发进行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="软件测试" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/06/04/hello-world/"/>
    <id>http://yoursite.com/2020/06/04/hello-world/</id>
    <published>2020-06-04T07:13:57.580Z</published>
    <updated>2020-06-04T07:13:57.580Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
